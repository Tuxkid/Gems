.Last.value <-
c(".Last.value", ".Random.seed", "FF", "Updown", "add.text", "agg", "allfit", 
    "ang.bt", "append.cols", "average.down", "bar.legs", "blank.plot", 
    "boxplot.fn", "broadcast", "check.fact", "check.na", "clg", "clipline", 
    "cloglog", "cloglog.bt", "colorps.trellis", "colour.chart", 
    "colour.chart2000", "cols.for.genstat", "comb", "complot", "count.nas", 
    "data.spot", "degree", "df.insert", "df.mat", "df.sort", "df.summary", 
    "df.to.file", "dmodes", "dmodes.f", "double.vector", "duplicate.rows", 
    "equal.count", "errorbars", "expand.cols", "factorize", "fieller", 
    "fill.down", "find.first", "find.first.test", "find.pos", "find.pos.mat", 
    "fitconf", "flex.contour", "flyplot", "formula.variables", "gen.write", 
    "get.col.names", "get.formula", "get.mort.tables", "glean.blank", 
    "graph.paper", "hort.colours", "incidence", "is.not.na", "junk.df", 
    "last.dump", "last.warning", "levels.for.genstat", "likelihood.ci", 
    "link.function", "link.inverse", "list.mat", "list.to.data.frame", 
    "log.mean", "logit.bt", "lookup", "make.df", "make.factors", "make.id", 
    "make.line.loess", "mean.effects.table", "mean.lc", "mean.lt", 
    "mean.lt.short", "modes", "month.length", "motif.l", "motif.n", "motif.p", 
    "motif.t", "motif.tp", "multi.nom", "my.var", "new.ps.colours", 
    "occurrence", "p.sunflowers", "panel.superpose", "plot.lt", "pool.adj", 
    "ppaste", "print.function", "ps.colors", "ps.colorsssss", "ps.print", 
    "pseudo.f", "qik.sum", "relevel", "relevel.default", "relevel.factor", 
    "remove.shading", "reorder", "rms", "robust.deviance", "s.tapply", 
    "save.new", "sem", "set.indentation", "set.screens", "show.nas", 
    "sim.beans", "simplot", "stdev", "strellis.device", "strip.trail", 
    "summarize", "summarize.new", "tab.file", "tab.mat", "table.all", "text.bp",
    "text.bp.new", "time.to.mort", "tuk.calc", "unfactor", "vec.insert", 
    "vect.to.character")
.Random.seed <-
c(45, 62, 42, 52, 51, 3, 39, 1, 26, 28, 44, 3)
FF <-
function(func, top.only = F, pos = NULL, ...)
{
# To print to screen (usually) a function with its directory, date, etc
# If it is not desired to have more than 1 match for "func", max=1 can
#   be put in the ... part 
    cat("*****************************************************")
    cat("\n")
    fun.text <- as.character(substitute(func))
    if(is.null(pos))
       pos <- find.pos(find(fun.text), search())
    pos1 <- pos[1]
    if(pos1 == 1)
       direc <- paste(unix("pwd"), "/.Data/", sep = "")
    else direc <- paste(search()[pos1], "/", sep = "")
    dir.info <- unix(paste("ls -la ", direc, fun.text, sep = ""))
    if(top.only) {
       for(i in pos) {
          if(i == 1)
             direc <- paste(unix("pwd"), "/.Data/", sep = "")
          else direc <- paste(search()[i], "/", sep = "")
          dir.info <- unix(paste("ls -la ", direc, fun.text, sep = ""))
          print(dmodes(fun.text, pos = i, ...))
          show.info <- substring(dir.info, 55, nchar(dir.info))
          cat(paste("Location:", show.info, "\n"))
       }
       return(invisible())
    }
    else {
       print(dmodes(fun.text, pos = pos, ...))
       show.info <- substring(dir.info, 55, nchar(dir.info))
       cat(paste("Location:", show.info, "\n"))
       cat("*****************************************************")
       cat("\n\n")
       oldoptions <- options(width = 88)
       on.exit(options(oldoptions))
       get(fun.text, pos)
    }
}
Updown <-
function(cv)
{
# Bill Venables's function (adjusted) to make uppercase first letters, and lower the rest.
    cv <- casefold(cv)
    first <- substring(cv, 1, 1)
    FIRST <- casefold(first, upper = T)
    paste(FIRST, substring(cv, 2), sep = "")
}
add.text <-
function(xp = 0.5, yp = 0.5, tex = NULL, ygap = 0.050000000000000003, cex = 
    0.80000000000000004, adj = 0, font = 1, srt = 0, ...)
{
# Cut down from bar.legs: used only for text; can also be rotated
# labels is character vector of legend text
# the length of tex sets the length of other vectors
# 
# 
# Establish positions in page co-ordinates [0,1] then use regular text function
    uu <- par()$usr
    xd <- diff(uu[1:2])
    yd <- diff(uu[3:4])
    yp <- yp - (seq(along = tex) - 1) * ygap
    if(length(xp) == 1)
       xp <- rep(xp, length(tex))
    if(length(cex) == 1)
       cex <- rep(cex, length(xp))
    if(length(adj) == 1)
       adj <- rep(adj, length(xp))
    if(length(font) == 1)
       font <- rep(font, length(xp))
    xh <- uu[1] + xd * xp
    yh <- uu[3] + yd * yp
    for(i in 1:length(tex)) {
       text(xh[i], yh[i], tex[i], adj = adj[i], cex = cex[i], font = font[i], 
          srt = srt, ...)
    }
}
agg <-
function(data, by, FUNS)
{
#
#   DATE WRITTEN:  14 May 1998
#   AUTHOR:  John R. Wallace (jrw@fish.washington.edu)
#
    out <- aggregate.data.frame(data, by, eval(parse(text = FUNS[1])))
    for(i in 2:length(FUNS)) {
       tmp <- aggregate.data.frame(data, by, eval(parse(text = FUNS[i])))
       tmp <- tmp[, ncol(tmp)]
       out <- cbind(out, tmp)
    }
    dimnames(out)[[2]][ - (1:length(by))] <- FUNS
    out
}
allfit <-
function(choice = 1, mn = NULL, xfun = function(x)
x, xfun.inv = NULL, datafun = glean.ramp, link = "cloglog", interval = T, pc = 
    c(50, 95, 99), pc.monotone = c(loess = 50, loess = 99), plot.monotone = 
    NULL, cutoff.mono = 0, span.mono = 1, pc.spline = NULL, plot.spline = F, 
    p.min = NULL, printdat = F, save.resid = F, cm.strategy = "adjust.later", 
    ext = "", cm.code = NULL, print.plot = F, full.robust = F, ...)
{
#Changed May 1999 to make pc = 95 part of the default
    xtra <- list(...)
    new.page <- T
    if(!is.null(names(xtra))) {
       h <- xtra$h
       ri <- xtra$ri
       cj <- xtra$cj
       if(any(is.na(match(names(xtra), c("h", "ri", "cj")))))
          cat("\n*** There are one or more illegal parameters to allfit()\n", 
             "from among the names:", names(xtra), "***\n")
    }
    else {
       ri <- 3
       cj <- 4
       h <- NULL
    }
    if(is.character(choice))
       cat(choice)
    if((!is.null(plot.monotone)) | plot.spline) {
       oldpar <- par(mfrow = c(ri, cj), oma = c(0, 1, 5, 0))
       on.exit(par(oldpar))
    }
    cat("   ", date(), fill = T)
    cat("** Link =", link, "**  x-transformation =", as.character(substitute(
       xfun)), "**", fill = T)
    if(!is.null(h))
       u <- datafun(choice = choice, h = h)
    else u <- datafun(choice = choice)
    if(is.null(cm.code))
       cm.code <- u$cm.code
    if(is.null(cm.code))
       cm.code <- 0
    cm.allcodes <- u$cm.allcodes
    temp <- u$temp
    stage <- u$stage
    if(all(xfun(exp(1:5)) == (1:5)))
       takelog <- T
    else takelog <- F
    idset <- u$id
    uset <- u$trial.id.order
    if(is.null(uset))
       uset <- unique(idset)
    if(is.null(mn))
       mn <- 1:length(uset)
    if(max(mn) > length(uset)) {
       maxj <- length(uset)
       cat("You have specified a final dataset no.", max(mn), "\nwhereas", maxj,
          "datasets only are available\n")
       keep <- mn <= maxj
       if(sum(keep) > 0)
          mn <- mn[keep]
       else stop(paste("Dataset(s)", mn, "not found."))
    }
    alltimes <- u$times
    alltot <- u$total
    alldead <- u$dead
    cm <- u$cm
    cmtot <- u$cmtot
    cutx <- u$cutx
    offset <- u$offset
    xaxtitle <- u$xaxtitle
    treat <- u$treat
    maint <- u$maint
    add.main <- u$add.main
    legend <- u$legend
    leg.brief <- u$leg.brief
    xxlabels <- u$xlabels
    here <- !is.na(alltimes) & !is.na(alldead) & !is.na(alltot)
    print(maint)
    if(!is.null(pc)) {
       ltmat <- matrix(, nrow = length(mn), ncol = length(pc))
       semat <- matrix(, nrow = length(mn), ncol = length(pc))
       dimnames(ltmat) <- list(NULL, paste(pc))
    }
    else {
       ltmat <- NULL
       semat <- NULL
    }
    if(!is.null(pc.spline)) {
       ltmat.spline <- matrix(, nrow = length(mn), ncol = length(pc.spline))
       dimnames(ltmat.spline) <- list(NULL, paste(pc.spline))
    }
    else ltmat.spline <- NULL
    if(!is.null(pc.monotone)) {
       ltmat.monotone <- matrix(, nrow = length(mn), ncol = length(pc.monotone)
          )
       dimnames(ltmat.monotone) <- list(NULL, paste(pc.monotone))
    }
    else ltmat.monotone <- NULL
    dimnames(ltmat) <- list(NULL, paste(pc))
    dimnames(semat) <- list(NULL, paste(pc))
    b0 <- array(, length(mn))
    b1 <- array(, length(mn))
    cm.est <- array(, length(mn))
    dev <- array(, length(mn))
    df <- array(, length(mn))
    dev.robust <- array(, length(mn))
    df.robust <- array(, length(mn))
    times.list <- vector("list", length(mn))
    total.list <- vector("list", length(mn))
    resid.list <- vector("list", length(mn))
    resid.dev.list <- vector("list", length(mn))
    leg.allfit <- array(, length(mn))
    i <- 0
    for(j in mn) {
       i <- i + 1
       idj <- uset[j]
       here.j <- idset == idj & here
       leg <- legend[j]
       leg.allfit[i] <- leg
       dead <- alldead[here.j]
       tot <- alltot[here.j]
       mins <- alltimes[here.j]
       if(!is.null(cutx))
          cutoff <- cutx[j]
       else cutoff <- NULL
       if(!is.null(cm))
          cmj <- cm[j]
       else cmj <- NULL
       uu <- fitconf(link = link, mins, dead, tot, cutoff, offset, j, leg = leg,
          interval = interval, pc = pc, pc.spline = pc.spline, pc.monotone = 
          pc.monotone, plot.spline = plot.spline, plot.monotone = plot.monotone,
          cutoff.mono = cutoff.mono, span.mono = span.mono, xfun = xfun, cm = 
          cmj, numcm = cmtot[j], p.min = p.min, printdat = F, save.resid = 
          save.resid, cm.strategy = cm.strategy, cm.code = cm.code, cm.allcodes
           = cm.allcodes, xfun.inv = xfun.inv, full.robust = full.robust)
       if((!is.null(plot.monotone)) && prod(par()$mfg[1:2]) == 1) {
          new.page <- T
          mtext(paste(maint, add.main), 3, line = 2.75, outer = T, cex = 1)
          mtext("Curves & LT's are from smooths following monotone regression",
             3, line = -0.75, outer = T, cex = 0.80000000000000004)
       }
       if((!is.null(plot.monotone)) && prod(par()$mfg[1:2]) == prod(par()$mfg[3:
          4]) && print.plot && new.page) {
          dev.print(device = pscript, horiz = T)
          new.page <- F
       }
       if(printdat) {
          print(legend[j])
          print(cbind(mins, dead, tot))
       }
       ltmat[i,  ] <- uu$lt
       if(!is.null(ltmat.spline))
          ltmat.spline[i,  ] <- uu$lt.spline
       if(!is.null(ltmat.monotone))
          ltmat.monotone[i,  ] <- uu$lt.monotone
       semat[i,  ] <- uu$se
       b0[i] <- uu$b0
       b1[i] <- uu$b1
       dev[i] <- uu$dev
       df[i] <- uu$df
       cm.est[i] <- uu$cm
       dev.robust[i] <- uu$dev.robust
       df.robust[i] <- uu$df.robust
       resid.list[[i]] <- uu$resid
       resid.dev.list[[i]] <- uu$resid.dev
       times.list[[i]] <- uu$times
       total.list[[i]] <- uu$total
    }
    if((!is.null(plot.monotone)) && print.plot && new.page)
       dev.print(device = pscript, horiz = T)    #
    invisible(list(lt50 = NULL, lt99 = NULL, se50 = NULL, se99 = NULL, 
       intercept = b0, slope = b1, lt = ltmat, se = semat, lt.spline = 
       ltmat.spline, lt.monotone = ltmat.monotone, span.mono = span.mono, cutx
        = cutx, dev = dev, df = df, cm.strategy = cm.strategy, cm = cm.est, 
       cm.code = cm.code, dev.robust = dev.robust, df.robust = df.robust, 
       takelog = takelog, total = total.list, resid = resid.list, resid.dev = 
       resid.dev.list, times = times.list, datafun = as.character(substitute(
       datafun)), choice = choice, temp = temp, stage = stage, add.main = 
       add.main, legend = leg.allfit, leg.brief = leg.brief))
}
ang.bt <-
function(y)
{
    (sin(atan(1)/45 * y))^2 * 100
}
append.cols <-
function(data = natural.df, repeat.cols = 1:4, collapse.cols = 5:6, resp.id = 
    "Resp.id", out.col = "Response")
{
# By default repeats the first four columns twice and 
#    makes columns 5 and 6 into one
    data <- as.data.frame(data)
    if(is.numeric(repeat.cols))
       repeat.cols <- names(data)[repeat.cols]
    if(is.numeric(collapse.cols))
       collapse.cols <- names(data)[collapse.cols]
    repeat.df <- as.data.frame(data[, repeat.cols])
    collapse.df <- data[, collapse.cols]
    ind <- 1:nrow(repeat.df)
    repeat.times <- ncol(collapse.df)
    repeated.df <- as.data.frame(repeat.df[rep(ind, repeat.times),  ])
    names(repeated.df) <- repeat.cols    # if only one column
    repeated.df[, resp.id] <- rep(collapse.cols, rep(max(ind), repeat.times))
    right <- unlist(collapse.df)
    repeated.df[[out.col]] <- right
    unfactor(repeated.df)
}
average.down <-
function(x)
{
# uses fill.down() to average the missing values with ones present
    y <- fill.down(x)
    z <- rev(fill.down(rev(x)))
    xx <- (y + z)/2
}
bar.legs <-
function(xp = 0.5, yp = 0.5, ebv = NULL, labs = NULL, colour = F, pchs = 0:10, 
    ltys = iff(colour, rep(1, 10), 1:9), line.break = 0, cols = iff(colour, 1:
    10, rep(1, 20)), wid = 0.0070000000000000001, eq.tex.gap = T, ygap = ifelse(
    eq.tex.gap, 0.050000000000000003, 0.02), xgap = 0.01, leg.cex = 
    0.59999999999999998, point.cex = 0.80000000000000004, adj = 0, font = 1, 
    line.leng = ifelse(is.null(pchs), 0.029999999999999999, 
    0.050000000000000003), mixed = F, bar.lwd = par()$lwd, line.lwd = par()$lwd,
    pt.lwd = bar.lwd, pt.lty = 1)
{
# For placing legends with error bars and adjusting the spaces between lines
#
# xp and yp are x & y positions to begin
# ebv is vector of errorbars widths: or a list of two vectors (max and min)
# labels is character vector of legend text
# wid is "width" of errorbars: adjusts eps in errorbars function called from this one
# ygap space between elements of legend
# pchs is vector of plotting characters 
# mixed is T when mixed.text is to be used for mixing characters in labs
    uu <- par()$usr
    xd <- diff(uu[1:2])
    yd <- diff(uu[3:4])
    xh <- uu[1] + xd * xp
    yh <- uu[3] + yd * yp
    if(is.null(ebv)) xh <- xh - xgap * xd    # puts lines() back to xp
    if(!is.list(ebv)) {
# If ebv is a single vector, only one lot of error bars:
       for(i in 1:length(labs)) {
# If space between errorbars is to be made equal, start top of first error bar
#  at beginning of legend. Otherwise, the legend text is at that position.
# If errorbar spaces are to be equal, half adjustment is done before drawing one, 
#  otherwise, all adjustment happens after drawing each one.
          if(!eq.tex.gap) yh <- yh - ebv[i]    #	
          if(!is.null(ebv))
             errorbars(xh, yh, ebv[i], eps = wid * xd, lwd = bar.lwd)
          if(!is.null(pchs))
             points(xh + (line.leng/2 + xgap) * xd, yh, pch = pchs[i], cex = 
                point.cex, col = cols[i], lwd = pt.lwd, lty = pt.lty)
          if(!is.null(ltys))
             if(line.break > 0) {
                {
                   lines(xh + (c(0, line.leng/2 - line.break) + xgap) * xd, rep(
                      yh, 2), lty = ltys[i], col = cols[i], lwd = line.lwd)
                   lines(xh + (c(line.leng/2 + line.break, line.leng) + xgap) * 
                      xd, rep(yh, 2), lty = ltys[i], col = cols[i], lwd = 
                      line.lwd)
                }
             }
             else lines(xh + (c(0, line.leng) + xgap) * xd, rep(yh, 2), lty = 
                   ltys[i], col = cols[i], lwd = line.lwd)
          if(!is.null(labels)) {
             if(mixed)
                mixed.text(xh + (line.leng + xgap * 2) * xd, yh, labs[i], adj
                    = adj, cex = leg.cex, font = font)
             else text(xh + (line.leng + xgap * 2) * xd, yh, labs[i], adj = adj,
                   cex = leg.cex, font = font)
          }
# Move down the appropriate amount for the next one:
          yh <- yh - ifelse(eq.tex.gap, 0, ebv[i]) - ygap * yd
       }
    }
    else {
# Two error bars, maximums and minimums are drawn 
# Move starting point to allow for extra errorbar
       xh <- xh + (xgap + wid) * xd
       ebv1 <- ebv$max
       ebv2 <- ebv$min
       for(i in 1:length(labs)) {
          if(!eq.tex.gap)
             yh <- yh - ebv1[i]
          errorbars(xh - (xgap + wid) * xd, yh, ebv1[i], eps = wid * xd, lwd = 
             bar.lwd)
          errorbars(xh, yh, ebv2[i], eps = wid * xd, lwd = bar.lwd)
          if(!is.null(pchs))
             points(xh + (line.leng/2 + xgap) * xd, yh, pch = pchs[i], cex = 
                point.cex, col = cols[i], lwd = pt.lwd)
          if(line.break > 0) {
             {
                lines(xh + (c(0, line.leng/2 - line.break) + xgap) * xd, rep(yh,
                   2), lty = ltys[i], col = cols[i], lwd = line.lwd)
                lines(xh + (c(line.leng/2 + line.break, line.leng) + xgap) * xd,
                   rep(yh, 2), lty = ltys[i], col = cols[i], lwd = line.lwd)
             }
          }
          else lines(xh + (c(0, line.leng) + xgap) * xd, rep(yh, 2), lty = ltys[
                i], col = cols[i], lwd = line.lwd)
          if(!is.null(labels)) {
             if(mixed)
                mixed.text(xh + (line.leng + xgap * 2) * xd, yh, labs[i], adj
                    = adj, cex = leg.cex, font = font)
             else text(xh + (line.leng + xgap * 2) * xd, yh, labs[i], adj = adj,
                   cex = leg.cex, font = font)
          }
          yh <- yh - ebv1[i] - ygap * yd
       }
    }
}
blank.plot <-
function(x = 0, y = 0, ...)
{
# Does a blank plot.  
#
#  Useful if you want to change the axes on the current plot (in which case specify
#    par(new=F)) 
# Sometimes you might want to prevent plotting in one part of a multiplot page.
    plot(x, y, xlab = "", ylab = "", xaxt = "n", yaxt = "n", pch = " ", bty = 
       "n", ...)
}
boxplot.fn <-
function(x = delbbd.datf, floop = NULL, rloop = NULL, trans = function(z)
z, mod1 = 1, mod2 = 0, notch = F, subset = NULL, paste.cols = NULL)
{
# 1a) Adding Paste Columns
    if(!is.null(paste.cols) & !is.logical(paste.cols)) {
       indc <- apply(x[paste.cols], 1, paste, collapse = ":")    
    #ind <- match(indc, unique(indc))
       x <- cbind(indc, x)
       dimnames(x)[[2]][1] <- paste("treat", paste(paste.cols, collapse = ""), 
          sep = "")
       if(is.null(floop)) {
          floop <- 1
       }
       else {
          floop <- c(1, floop + 1)
       }
    }
# 1b) For loop for Responses
    for(j in rloop) {
       response.names <- dimnames(x)[[2]][j]
       response <- x[, j]
       if(!is.null(subset)) {
          response[response > subset] <- NA
       }
       yval <- trans(response/mod1 + mod2)    # 2) For loop for factors
       for(i in floop) {
          factors <- factor(x[, i])
          factor.names <- dimnames(x)[[2]][i]    # 3) Boxplot function
          plot.factor(factors, yval, xlab = factor.names, ylab = response.names,
             notch = notch, boxmeans = T, style.bxp = "old")
          if(i == floop[1] & j == rloop[1])
             mtext(paste(as.character(substitute(trans)), " ", as.character(
                substitute(x))), 3, cex = 1, line = 1.3999999999999999)
          dev.ask()
       }
    }
}
broadcast <-
function(x, frame = 1)
{
# To make an object visible to all functions the present function calls
#
#     similar to assign("object",object,frame=1)
    assign(as.character(substitute(x)), x, frame = frame)
}
check.fact <-
function(df)
{
#Checks if columns of dataframes are factors:
    sapply(df, is.factor)
}
check.na <-
function(df)
{
# Returns the number of NAs in any column of a dataframe
    sapply(df, function(x)
    sum(is.na(x)))
}
clg <-
function()
{
# Clears graphics window
    plot(0, 0, new = T, xaxt = "n", pch = " ", yaxt = "n", bty = "n", xlab = "",
       ylab = "")
}
clipline <-
function(xlim, ylim, a, b, funlog = function(x)
x, unlog = function(x)
x, lty = 1, lwd = 1)
{
    x0 <- xlim[1]
    y0 <- a + b * funlog(x0)
    x1 <- xlim[2]
    y1 <- a + b * funlog(x1)
    if(y0 < ylim[1]) {
       y0 <- ylim[1]
       x0 <- unlog((ylim[1] - a)/b)
    }
    else if(y0 > ylim[2]) {
       y0 <- ylim[2]
       x0 <- unlog((ylim[2] - a)/b)
    }
    if(y1 < ylim[1]) {
       y1 <- ylim[1]
       x1 <- unlog((ylim[1] - a)/b)
    }
    else if(y1 > ylim[2]) {
       y1 <- ylim[2]
       x1 <- unlog((ylim[2] - a)/b)
    }
    cat("     Join (", round(x0, 3), round(y0, 3), ") to (", round(x1, 3), 
       round(y1, 3), ")", fill = T)
    lines(c(x0, x1), c(y0, y1), lty = lty, lwd = lwd)
}
cloglog <-
function(pr)
{
    log( - log(1 - pr))
}
cloglog.bt <-
function(x)
{
# To calculate the proportion that gives the known complememtary log log value
    1 - exp( - exp(x))
}
colorps.trellis <-
structure(.Data = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 
    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
    37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 0, 0.020833333333333332,
    0.041666666666666664, 0.0625, 0.083333333333333329, 0.10416666666666666, 
    0.125, 0.14583333333333331, 0.16666666666666666, 0.1875, 
    0.20833333333333331, 0.22916666666666666, 0.25, 0.27083333333333331, 
    0.29166666666666663, 0.3125, 0.33333333333333331, 0.35416666666666663, 
    0.375, 0.39583333333333331, 0.41666666666666663, 0.4375, 
    0.45833333333333331, 0.47916666666666663, 0.5, 0.52083333333333326, 
    0.54166666666666663, 0.5625, 0.58333333333333326, 0.60416666666666663, 
    0.625, 0.64583333333333326, 0.66666666666666663, 0.6875, 
    0.70833333333333326, 0.72916666666666663, 0.75, 0.77083333333333326, 
    0.79166666666666663, 0.8125, 0.83333333333333326, 0.85416666666666663, 
    0.875, 0.89583333333333326, 0.91666666666666663, 0.9375, 
    0.95833333333333326, 0.97916666666666663, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), .Dim = c(49, 4), .Dimnames = list(
    character(0), c("nos", "all.kullas", "all.shades", "")))
colour.chart <-
function(post = T, trellis = F, start1 = 1, start2 = 40, start3 = 79)
{
    if(trellis)
       ps.colors <- get("colorps.trellis", where = 
          "/export/home/local/splus34/library/trellis/.Data")
    ps.colours <- ps.colors
    if(post) {
       trellis.device(postscript, file = "Colours.test.ps", pointsize = 20, 
          color = T, horizontal = F)
       par(lwd = 20)
       on.exit(dev.off())
    }
    ygap <- 0.012
    break1 <- start2 - 1
    break2 <- start3 - 1    # browser()
    par(omi = rep(0, 4), mai = rep(0, 4))
    bar.legs(0.12, 0.69999999999999996, labs = paste(start1:break1), colour = T,
       ltys = rep(1, (start2 - start1)), cols = start1:break1, pchs = NULL, 
       line.leng = 0.14999999999999999, xgap = 0.029999999999999999, ygap = 
       ygap, leg.cex = 0.40000000000000002, adj = 1)
    bar.legs(0.41999999999999998, 0.69999999999999996, labs = paste(start2:
       break2), colour = T, ltys = rep(1, (start3 - start2)), cols = start2:
       break2, pchs = NULL, line.leng = 0.14999999999999999, xgap = 
       0.029999999999999999, ygap = ygap, leg.cex = 0.40000000000000002, adj = 
       1)
    bar.legs(0.71999999999999997, 0.69999999999999996, labs = paste(start3:116),
       colour = T, ltys = rep(1, (117 - start3)), cols = start3:117, pchs = 
       NULL, line.leng = 0.14999999999999999, xgap = 0.029999999999999999, ygap
        = ygap, leg.cex = 0.40000000000000002, adj = 1)
    invisible()
}
colour.chart2000 <-
function(post = T)
{
    if(post) {
       trellis.device(postscript, file = "Colours.test.ps", pointsize = 20, col
           = T, horizontal = F)
       par(lwd = 25)
       on.exit(dev.off())
    }
    ygap <- 0.021000000000000001
    start <- 2
    bar.legs(0.29999999999999999, 1, labs = paste(start:49), colour = T, ltys
        = rep(1, 49), cols = start:49, pchs = NULL, line.leng = 
       0.55000000000000004, xgap = 0.10000000000000001, ygap = ygap, adj = 1)
    ps.colours <- ps.colors
    ps.colours[, 2] <- format(ps.colours[, 2])
    for(i in start:49) {
       add.text(0.10000000000000001, 1 - (i - start) * ygap, tex = ps.colours[i,
          2], adj = 1, cex = 0.40000000000000002)
       add.text(0.20000000000000001, 1 - (i - start) * ygap, tex = ps.colours[i,
          3], adj = 1, cex = 0.40000000000000002)
       add.text(0.25, 1 - (i - start) * ygap, tex = ps.colours[i, 4], adj = 1, 
          cex = 0.40000000000000002)
    }
}
cols.for.genstat <-
function(x, num = F)
{
# Returns a string of the column names to use in genstat
# need only to change the opening and closing " and  to '
    y <- names(x)
    paste(y, collapse = ", ")
}
comb <-
function(N, x)
{
    gamma(N + 1)/gamma(x + 1)/gamma(N - x + 1)
}
complot <-
function(data, xtitle = "Time (Minutes)", main = "", yfun = "cloglog", logx = F,
    title.line = 1, plimits = c(0.040000000000000001, 0.99950000000000006), 
    xtix = NULL, ytit = NULL, labp = NULL, lty = 1, colours = F, dot.marks = T,
    xlab.line = 2, x.mgp = 0.10000000000000001, y.mgp = ifelse(post, 0.5, 
    0.59999999999999998), ylab.line = 1.6000000000000001, pchs = c(0, 1, 2, 5, 
    6:16), id = NULL, ab.lty = 2, lab.cex = 1, ax.cex = 0.80000000000000004, 
    main.cex = 1.1000000000000001, point.cex = 0.90000000000000002, 
    mark.control = F, ...)
{
# Modified (very) version of simplot
# 
# data is a dataframe of the sets to be plotted on one plot.
#  with names of columns: Time, Dead, Total, Id	
#
# xfun is the function to be applied to the x axis data before plotting it.
#   It ia a list which will be extended to the same length as the number of sets
#   of points to be plotted (unless already given as that length). 
#
# y.mgp is the second value in an mgp parameter
# x.mgp is the amount by which the corresponding x axis parameter is decreased
#
# dot.marks: Mark 100% and 0% points with dots?
    post <- names(dev.cur()) == "postscript"
    par(...)
    if(logx)
       f <- log
    else f <- function(x)
       x
    if(logx)
       stop(
          "\ncomplot function needs fixing to do log transformation on x-axis")
    u.id <- unique(data$Id)
    g <- link.function(yfun)
    broadcast(g)    #
# Identify Control and Treatment data:
    if(logx)
       data <- data[data$Time > 0,  ]
    data$Mort <- data$Dead/data$Total
    if(is.null(xtix))
       x.range <- range(data$Time)
    else x.range <- range(xtix)
    p.range <- range(data$Mort)    #
# Calculate adjustments for the space on the y-axis:
    ylow <- g(plimits[1])
    yhigh <- g(plimits[2])
    eps <- (yhigh - ylow) * 0.01
    ylow <- ylow - eps
    yhigh <- yhigh + eps
    if(is.null(labp))
       labp <- c(1, 5, 10, 25, 50, 75, 95, 99)
    labp <- labp[labp/100 >= plimits[1] & labp/100 <= plimits[2]]    #
# Set up blank plot: (uses blank.plot() in /home/hrapgc/Gems/.Data/ )
    blank.plot(f(x.range), c(ylow, yhigh), ...)
    usr <- par()$usr
    epsx <- 0.012500000000000001 * diff(usr[1:2])
    epsy <- 0.012500000000000001 * diff(usr[3:4])
    midhigh <- 0.5 * (yhigh + usr[4])
    midlow <- 0.5 * (ylow + usr[3])
    hundred.line <- F
    zero.line <- F
    colour <- is.numeric(colours)
    for(i in u.id) {
       df.i <- data[data$Id == i,  ]
       attach(df.i)    #
# Plot "normal" points:
       time <- Time[Mort > plimits[1] & Mort < plimits[2]]
       mort <- Mort[Mort > plimits[1] & Mort < plimits[2]]
       points(f(time), g(mort), pch = pchs[i], col = ifelse(colour, colours[i],
          1), cex = point.cex)    #
# Plot "high" points (i.e. ones near 100%)
       high.mort <- Mort[Mort > plimits[2]]
       high.time <- Time[Mort > plimits[2]]
       points(f(high.time), rep(midhigh, length(high.time)), pch = pchs[i], cex
           = point.cex, col = ifelse(colour, colours[i], 1))
       if(any(Mort == 1)) {
          hundred.line <- T
          full.mort <- Mort[Mort == 1]
          full.time <- Time[Mort == 1]
          if(dot.marks)
             points(f(full.time), rep(midhigh, length(full.time)), pch = ".", 
                cex = point.cex, col = ifelse(colour, colours[i], 1))
       }
# Plot "low" points (i.e. ones near 0%)
       low.mort <- Mort[Mort < plimits[1]]
       low.time <- Time[Mort < plimits[1]]
       points(f(low.time), rep(midlow, length(low.time)), pch = pchs[i], cex = 
          point.cex, col = ifelse(colour, colours[i], 1))
       if(any(Mort == 0)) {
          zero.line <- T
          zero.mort <- Mort[Mort == 0]
          zero.time <- Time[Mort == 0]
          if(logx) {
             zero.time <- zero.time[zero.time > 0]
             zero.mort <- zero.mort[zero.time > 0]
          }
          if(dot.marks)
             points(f(zero.time), rep(midlow, length(zero.time)), pch = ".", 
                cex = point.cex)
       }
       cont.mort <- Mort[Time == 0]
       if(mark.control) {
# Mark control mortalities:
          if(any(cont.mort < plimits[1])) text(0, midlow, "C") else text(0, g(
                cont.mort), "C", cex = point.cex)
       }
       detach("df.i")
    }
# Do tricky things to y-axis:
    mgp <- c(3, y.mgp, 0)
    axis(2, at = g(labp/100), labels = paste(labp), adj = 1, mgp = mgp, cex = 
       ax.cex)
    axis(2, at = c(ylow + 2 * epsy, yhigh - 2 * epsy), labels = F, tck = 0)
    for(k in 1:2) {
       y.end <- c(ylow, yhigh)[k]
       axis(2, at = c(y.end, usr[2 + k]), labels = F, tck = 0)
    }
    if(zero.line)
       abline(h = ylow, lty = ab.lty)
    if(hundred.line)
       abline(h = yhigh, lty = ab.lty)
    axis(2, at = midlow, tck = 0, labels = "0", adj = 1, mgp = mgp, cex = 
       ax.cex)
    lines(usr[1] + c( - epsx, epsx), c(ylow - 1.5 * epsy, ylow + 1.5 * epsy), 
       xpd = T)
    lines(usr[1] + c( - epsx, epsx), c(ylow + 0.5 * epsy, ylow + 3.5 * epsy), 
       lty = lty, xpd = T)
    axis(2, at = midhigh, tck = 0, labels = "100", adj = 1, mgp = mgp, cex = 
       ax.cex)
    lines(usr[1] + c( - epsx, epsx), c(yhigh - 1.5 * epsy, yhigh + 1.5 * epsy),
       xpd = T)
    lines(usr[1] + c( - epsx, epsx), c(yhigh - 3.5 * epsy, yhigh - 0.5 * epsy),
       lty = lty, xpd = T)    #
# Make x-axis and labels
    if(is.null(xtix))
       xlab.pos <- pretty(range(data$Time))
    else xlab.pos <- xtix
    if(logx)
       xlab.pos <- xlab.pos[xlab.pos > 0]
    axis(1, at = f(xlab.pos), labels = paste(xlab.pos), cex = ax.cex, mgp = mgp -
       c(0, x.mgp, 0))
    cat(xlab.pos, "  \n")    # xlab.pos specifies numeric labels
# Add break in x-axis if necessary: fill in left space
    if(logx) {
       x.cut1 <- diff(usr[1:2]) * 0.029999999999999999 + usr[1]
       x.cut2 <- diff(usr[1:2]) * 0.5 + usr[1]
       axis(1, at = c(usr[1], x.cut1), labels = F, tck = 0)
       axis(1, at = c(x.cut2, usr[2]), labels = F, tck = 0)
       lines(x.cut1 + c( - epsx, epsx), usr[3] + 2 * c( - epsy, epsy), xpd = T)
       lines(x.cut2 + c( - epsx, epsx), usr[3] + 2 * c( - epsy, epsy), xpd = T)
    }
    else lines(usr[1:2], usr[c(3, 3)])
    mtext(side = 1, line = xlab.line, text = xtitle, cex = lab.cex)
    mtext(side = 2, line = ylab.line, text = ifelse(is.null(ytit), paste(
       "% Mortality,", yfun, "scale"), ytit), cex = lab.cex)
    mtext(side = 3, text = main, cex = main.cex)
    box(bty = "7")
}
count.nas <-
function(df)
{
# counts nas in columns of a dataframe have nas.
#
    sapply(df, function(x)
    sum(is.na(x)))
}
data.spot <-
function(ab, use, id = NULL, separate = T)
{
# To show table of times, dead and total to correspond to selected 
#   parts of ab type list of the form ab$use
# If id is not specified, all values will be shown
# separate will group each section and names individually, othewise
#   only one table will be made
#
# WARNING: Will crash if the legends are not unique 
    names.ab <- names(ab)
    if(length(use) > 1)
       stop("use can be of length 1 only")
    if(is.character(use))
       ab.sub <- (1:length(names.ab))[!is.na(match(names.ab, use))]
    else ab.sub <- use
    aab <- ab[[ab.sub]]
    glean <- aab$datafun
    choice <- aab$choice
    glean.fn <- get(glean)
    glean.list <- glean.fn(choice)
    df <- data.frame(id = glean.list$id, time = glean.list$times, dead = 
       glean.list$dead, total = glean.list$total)
    df$live <- df$total - df$dead
    df <- df[, c("id", "time", "live", "dead", "total")]
    df$mort <- round(df$dead/df$total * 100)
    if(is.null(id))
       out.df <- df
    else out.df <- df[!is.na(match(df[["id"]], id)),  ]
    print(glean.list$maint)
    out.list <- list()
    browser()
    if(separate) {
       if(is.null(id))
          id <- unique(df$id)
       for(i in id)
          out.list[[glean.list$legend[i]]] <- df[df$id == i,  ]
       out.list
    }
    else {
       if(!is.null(id))
          print(glean.list$legend[id])
       out.df
    }
}
degree <-
function(x)
{
    paste(x, All.ASCII[203], "C", sep = "")
}
df.insert <-
function(rows, into, at)
{
# For inserting rows of a dataframe into another dataframe at designated rows.
# "at" is a vector of row numbers in the original df ("into") at which insertion 
#   is req'd and should be the same length as the no of rows of "rows".
    if(dim(rows)[2] != dim(into)[2]) stop(
          "Number of columns must be the same in both dataframes")
    at.inc <- at
    for(a in 1:length(at)) {
       if(at.inc[a] == 1)
          top <- NULL
       else top <- into[1:(at.inc[a] - 1),  ]
       bottom <- into[at.inc[a]:dim(into)[1],  ]
       into <- rbind(top, rows[a,  ], bottom)
       at.inc <- at.inc + 1
    }
    into
}
df.mat <-
function(df)
{
# Coerces a dataframe to a matrix, retaining levels instead of codes 
#  for any factors: see unfactor()
    mat <- as.matrix(unfactor(df))
    mat
}
df.sort <-
function(dfm, sort.by = names(dfm)[1], backwards = F)
{
# To sort the rows of a dataframe into an order set by vector "sort.by"
# If sort.by is numeric it is the column nos; if character, the column names.
    if(is.character(sort.by)) {
       sort.by.n <- match(sort.by, names(dfm))
       if(length(which.na(sort.by.n)) > 0) {
          stop(paste("\n", sort.by[which.na(sort.by.n)], 
             "is not a recognised name"))
       }
       else sort.by <- sort.by.n
    }
    for(i in sort.by) {
       dfm.i <- dfm[order(dfm[, i]),  ]
       if(backwards)
          dfm.i <- dfm[(reverse(order(dfm[, i]))),  ]
       dfm <- dfm.i
    }
    dfm
}
df.summary <-
function(data, y.cols = NULL, split.cols = NULL, rep.col = "Rep", decimals = 3,
    stats = "mean", help = F)
{
# cut down and modified from summarize()
# Keep Stephen's beginning:
# Requires text.bp() and df.to.file() 
#   [anything else will be in   /home/hrapgc/Gems/.Data]
    summary.names <- c("N", "Missing", "Mean", "Median", "Trimmed Mean", 
       "Std. Dev.", "SEM", "Min", "Max", "1st Quartile", "3rd Quartile", "Sum",
       "Boxplots")
    summary.types <- c("num", "missing", "mean", "median", "trm", "stdev", 
       "sem", "min", "max", "q1", "q3", "sum", "boxplots")
    help.df <- (data.frame("Select one of these" = summary.types, "to get this"
        = summary.names))
    if(help) {
       cat("\n In the argument \"stats\"\n")
       print(help.df)
       return()
    }
# A few error messages:
    if(len(stats) > 1)
       stop(
          "\n\tOnly one statistic can be calculated at a time:\n\tIf you require multiple stats with only one y.cols, \n\tyou can use summarize() with df.out set to TRUE"
          )
    broadcast(decimals)    #
# Make special functions to use in apply calls
    q1 <- function(x)
    quantile(x, na.rm = T)[2]
    q3 <- function(x)
    quantile(x, na.rm = T)[4]
    no.missing <- function(x)
    length(x[is.na(x)])
    round.mean <- function(x, y = decimals)
    round(mean(x, na.rm = T), y)
    round.sem <- function(x, y = decimals)
    round(sem(x, na.rm = T), y)
    round.sum <- function(x, y = decimals)
    round(sum(x, na.rm = T), y)
    add.boxplot <- function(x, y.range = range.j, width = bp.width)
    text.bp(x, y.range, width)    #
# Functions are now set up:
#
# Make named vector of functions to be used:
    use.functions <- c("len", "no.missing", "round.mean", "median", "trm", 
       "stdev", "round.sem", "min", "max", "q1", "q3", "round.sum", 
       "add.boxplot")
    names(use.functions) <- summary.types
    names(summary.names) <- summary.types    #
# Use dataframes instead of matrices:
    if(is.matrix(data))
       data <- unfactor(as.data.frame(data))
    else data <- unfactor(data)    # avoid pesky factors
    data <- df.sort(data, rev(split.cols))    #
# Make character vectors of y.cols and split.cols if necessary:
    if(is.numeric(y.cols))
       y.cols <- names(data)[y.cols]
    if(is.numeric(split.cols)) split.cols <- names(data)[split.cols]    #
# Create index and adjust for single split columns if necessary:
    indx.df <- data.frame(data[, split.cols])
    names(indx.df) <- split.cols    # Necessary for single split.cols
    attach(indx.df)
    indx <- NULL
    for(i in split.cols)
       indx <- paste(indx, get(i), sep = ":")
    detach("indx.df")
    out.df <- data.frame(indx.df[match(unique(indx), indx), split.cols])
    names(out.df) <- split.cols    # Necessary for single split.cols
    dimnames(out.df) <- list(paste(1:nrow(out.df)), names(out.df))
    for(j in y.cols)
       out.df[, j] <- s.tapply(data[, j], indx, get(use.functions[stats]))
    out.df
}
df.to.file <-
function(df = unfactor(junk.df), pad = "mid", file = "", append = F)
{
# To print a data frame to a text file and having names line up with values
#    underneath, and no need to use tab spacing
#
#  Set up some padding functions:  Need columns with same number of characters
#    all the way down.
    pad.char.cols <- function(y)
    {
# For padding character columns
       biggest <- max(nchar(y))
       col.width <- nchar(y)
       padding <- paste(rep(" ", biggest - min(col.width)), collapse = "")
       out <- substring(paste(y, padding, sep = ""), 1, biggest)
       out
    }
    pad.left <- function(z, pads)
    {
       padding <- paste(rep(" ", pads), collapse = "")
       paste(padding, z, sep = "")
    }
    pad.mid <- function(z, pads)
    {
# Centres text in available space
       padding.right <- paste(rep(" ", pads %/% 2), collapse = "")
       padding.left <- paste(rep(" ", pads - pads %/% 2), collapse = "")
       paste(padding.left, z, padding.right, sep = "")
    }
    pad.right <- function(z, pads)
    {
       padding <- paste(rep(" ", pads), collapse = "")
       paste(z, padding, sep = "")
    }
# Character columns need different treatment from numeric columns
    char.cols <- sapply(df, is.character)
    df[char.cols] <- sapply(df[char.cols], pad.char.cols)
    df[!char.cols] <- sapply(df[!char.cols], format)    #
# Sometimes the names of columns are wider than the columns they name, 
#  sometimes vice versa.
    names.width <- nchar(names(df))
    row.width <- sapply(df, function(x)
    max(nchar(x)))    #
# (the width of the characters in the columns (and rows) as distinct from the names
    name.pads <- row.width - names.width
    row.pads <- name.pads * -1
    name.pads[name.pads < 0] <- 0
    row.pads[row.pads < 0] <- 0
    pad.names <- name.pads > 0
    pad.rows <- row.pads > 0    #
# Pad out the column names if necessary:
    pad.funct <- get(paste("pad.", pad, sep = ""))
    if(any(pad.names)) {
       stretch.names <- names(df)[pad.names]
       for(i in stretch.names) {
          names(df)[names(df) == i] <- pad.funct(i, name.pads[i])
       }
    }
# likewise for the rows and columns
    if(any(pad.rows)) {
       stretch.rows <- names(df)[pad.rows]
       for(j in stretch.rows)
          df[, j] <- pad.funct(df[, j], row.pads[j])
    }
# the write() function doesn't use the names of the matrix, so put them
#   into it.
    df2 <- rbind(names(df), as.matrix(df))
    write(t(df2), file, ncol(df2), append = append)
}
dmodes <-
function(x = "", pos = 1, max = NULL, sort.by = "Date")
{
# Returns a Data frame showing modes of objects in the stated directory.
# Can be sorted by Mode, Length, or Date in addition to default Object
# A variation on this one is modes(). Made for lazy typists to sort by object name 
# max is the maximum number of objects returned; useful if ls() is long and 
#  you're only interested in the first few
    ls.o <- ls(x, pos = pos)
    if(!is.null(max) & max > length(ls.o))
       print(paste("Only", length(ls.o), "match", x, "in", search()[pos], 
          "directory"))
    if(is.null(max) | (max > length(ls.o)))
       max <- length(ls.o)
    if(sort.by == "Date")
       dir <- unix(paste("ls -lat ", search()[pos], sep = ""))
    else dir <- unix(paste("ls -la ", search()[pos], sep = ""))    #
    dir.names <- substring(dir, 55, nchar(dir))    #
# Will contain .Audit and .. files that aren't in the ls() list
    want <- match(dir.names, ls.o)
    wants <- want[!is.na(want)][1:max]
    options(warn = -1)
    on.exit(options(warn = 0))
    out <- list()
    dir.objs <- ls.o[wants]
    out$Object <- dir.objs
    objs.mat <- cbind(dir.objs)
    out$Mode <- apply(objs.mat, 1, function(x)
    mode(get(x)))    #
# Dimension information of dataframes and matrices
    dimensions <- apply(objs.mat, 1, function(x)
    dim(get(x)))
    y <- dimensions
    if(!is.null(y)) {
       if(is.list(y)) {
          y[unlist(lapply(y, is.null))] <- list(c(NA, NA))
          z <- t(matrix(unlist(y), byrow = F, nc = len(y)))
          z[is.na(z)] <- "-"
          out$Rows <- z[, 1]
          out$Cols <- z[, 2]
       }
       else {
# otherwise it's a matrix which will work differently
          out$Rows <- y[1,  ]
          out$Cols <- y[2,  ]
       }
    }
    else out$Cols <- out$Rows <- rep("-", len(out$Object))
    out$Len <- apply(objs.mat, 1, function(x)
    length(get(x)))    #
# Rearrange date information
    date.info <- substring(dir, 42, 53)[find.pos(dir.objs, dir.names)]
    year <- substring(date.info, 8, 12)
    day <- substring(date.info, 5, 6)
    month <- substring(date.info, 1, 3)
    out$Date <- paste(day, month, year)
    long.name <- max(c(7, nchar(out$Object)))    #allow for shortnames
    ob.spaces <- long.name/2 - 3
    out$Mode[out$Mode == "list" & out$Rows != "-"] <- "dataframe"
    out.df <- unfactor(as.data.frame(out), c("Object", "Mode"))
    if(sort.by != "Date") out.df <- out.df[order(out.df[, sort.by]),  ]    #
# If date order is wanted, use the Unix ls, sorted by date, otherwise sort 
#   in S
    names(out.df) <- c(paste("Object", paste(rep(" ", ob.spaces), collapse = ""
       )), "Mode  ", "Rows", "Cols", "Len", "Date    ")
    out.df
}
dmodes.f <-
function(x = "", pos = 1, max = NULL, sort.by = "Date")
{
# Returns a Data frame showing all function objects in nominated directory.
#
# max is the maximum number of objects returned; useful if ls() is long and 
#  you're only interested in the first few
# Can be sorted by Object name instead of Date
    ls.all <- ls(x, pos = pos)
    ls.o <- ls.all[apply(matrix(ls.all, nc = 1), 1, function(x)
    is.function(get(x)))]
    if(!is.null(max) & max > length(ls.o))
       print(paste("Only", length(ls.o), "in", search()[pos], "directory"))
    if(is.null(max) | (max > length(ls.o)))
       max <- length(ls.o)
    if(sort.by == "Date")
       dir <- unix(paste("ls -lat ", search()[pos], sep = ""))
    else dir <- unix(paste("ls -la ", search()[pos], sep = ""))    #
    dir.names <- substring(dir, 55, nchar(dir))    #
# Will contain .Audit and .. files that aren't in the ls() list
    want <- match(dir.names, ls.o)
    wants <- want[!is.na(want)][1:max]
    options(warn = -1)
    on.exit(options(warn = 0))
    out <- list()
    dir.objs <- ls.o[wants]
    out$Object <- dir.objs
    objs.mat <- cbind(dir.objs)
    out$Mode <- apply(objs.mat, 1, function(x)
    mode(get(x)))    #
    out$Len <- apply(objs.mat, 1, function(x)
    length(get(x)))    #
# Rearrange date information
    date.info <- substring(dir, 42, 53)[find.pos(dir.objs, dir.names)]
    year <- substring(date.info, 8, 12)
    day <- substring(date.info, 5, 6)
    month <- substring(date.info, 1, 3)
    out$Date <- paste(day, month, year)
    long.name <- max(nchar(out$Object))
    ob.spaces <- long.name/2 - 5
    out.df <- unfactor(as.data.frame(out), c("Object", "Mode"))
    if(sort.by != "Date") out.df <- out.df[order(out.df[, sort.by]),  ]    #
# If date order is wanted, use the Unix ls, sorted by date, otherwise sort in S
    names(out.df) <- c(paste("Object", paste(rep(" ", 5), collapse = "")), 
       "Mode  ", "Len", "Date    ")
    out.df
}
double.vector <-
function(x, y, sep = "")
{
# Used to make a vector that has all combinations of the elements 
#  of two other vectors
    xy <- paste(rep(x, rep(length(y), length(x))), y, sep = sep)
}
duplicate.rows <-
function(df, row.names.only = F)
{
# Returns a dataframe (or matrix) of duplicated rows in df
#
#  Might do strange things with factors and codes, but maybe not.
    pdf <- do.call("paste", as.data.frame(df))
    if(sum(duplicated(pdf)) > 0) {
       dup.rows <- grep(pdf[duplicated(pdf)], pdf)
       if(row.names.only) {
          if(is.null(dimnames(df)[[1]]))
             dup.rows
          else dimnames(df)[[1]][dup.rows]
       }
       else df[dup.rows,  ]
    }
    else cat(paste("No duplicates in", as.character(substitute(df)), "\n"))
}
equal.count <-
function(x, number = 6, overlap = 0.5)
{
# To fix up a bug in the equal.count in /usr/local/splus/library/trellis/.Data
    X <- sort(x)
    if(overlap >= 1) {
       m.per.int <- (length(X) + (number - 1) * overlap)/number
       m.over <- overlap
    }
    else {
       m.per.int <- length(X)/(number * (1 - overlap) + overlap)
       m.over <- overlap * m.per.int
    }
    left <- round((0:(number - 1)) * (m.per.int - m.over)) + 1
    right <- round((1:number) * (m.per.int - m.over) + m.over)
    shingle(x, cbind(X[left], X[right]))
}
errorbars <-
function(x, y, se, yl = y - se, yu = y + se, eps, ...)
{
    if(any(is.na(yl)) | any(is.na(yu)))
       text(x[is.na(yl) | is.na(yu)], y[is.na(yl) | is.na(yu)], "NA", adj = 1)
    segments(x, yl, x, yu, ...)
    segments(x - eps, yl, x + eps, yl, ...)
    segments(x - eps, yu, x + eps, yu, ...)
}
expand.cols <-
function(mat = consumer.72.dat)
{
    df <- as.data.frame(mat)
    df.out <- data.frame(consumer = seq(1, 72))
    for(i in unique(sort(df$code))) {
       df.i <- df[df$code == i,  ]
       df.i <- df.sort(df.i, "consumer")
       df.out[[paste(i)]] <- df.i$overall
    }
    df.out
}
factorize <-
function(n)
{
    p <- n/(z <- 1:ceiling(sqrt(n)))
    z <- z[trunc(p) == p]
    unique(c(z, rev(n/z)))
}
fieller <-
function(phat, a, b, v11, v12, v22, df.t = Inf, link = "logit")
{
# fiducial interval calculation from Finney p.78
#
# a,b 			estimated intercept and slope
# v11, v12, v22 	variance and covariance of estimates of a and b
# t		 	t statistic
#
    if(df.t == Inf) tt <- 1.96 else tt <- qt(0.97499999999999998, df.t)
    g.link <- link.function(link)
    a <- g.link(phat) - a
    v12 <- .Uminus(v12)
    m <- a/b
    g <- (gg <- (tt/b)^2) * v22
    if(g > 0.98999999999999999 || g < 0) {
       return(list(xhat = m, ci = NULL, lower = 1, upper = -1, g = g))
    }
    xhat0 <- m + g/(1 - g) * m - gg/(1 - g) * v12
    vv <- v11 - 2 * m * v12 + m^2 * v22 - g * v11 + gg * v12^2
    Ix <- tt/b/(1 - g) * sqrt(vv)
    Ix <- abs(Ix)
    list(xhat = m, var = vv, lower = xhat0 - Ix, upper = xhat0 + Ix, g = g)
}
fill.down <-
function(x)
{
# Replaces NAs in a numeric vector or blanks in a character one 
#   with the value preceding it.  
#    Too lazy to use fill-down in Excel
#
#  Warning: Replaces an initial NA with a zero.  Might not always be appropriate.
    if(is.na(x[1])) x[1] <- 0
    stillsome <- T
    while(stillsome) {
       nas.at <- iff(is.character(x), x == "", is.na(x))
       na.indx <- seq(along = x)[nas.at]
       x[na.indx] <- x[na.indx - 1]
       stillsome <- length(na.indx) > 0
    }
    x
}
find.first <-
function(x, char = " ")
{
# Finds position of first occurence of a particular character in a character string
    if(!is.character(x)) stop(
          "find.first() applicable only for character strings")
    beg <- NULL
    for(k in 1:length(x)) {
       leg.vec <- paste(substring(x[k], 1:nchar(x[k]), 1:nchar(x[k])), sep = ""
          )
       beg[k] <- match(char, leg.vec)
    }
    beg
}
find.first.test <-
function(x, char = " ")
{
# Finds position of first occurrence of a particular character in a character string
    if(!is.character(x)) stop(
          "find.first() applicable only for character strings")
    z <- as.list(x)
    broadcast(char)
    find.gaps <- function(a, b)
    {
       size <- 1:nchar(a)
       (size)[substring(a, 1:nchar(a), 1:nchar(a)) == char]
    }
    broadcast(find.gaps)
    y <- lapply(z, function(w)
    find.gaps(w, b = char))
    browser()
    unlist(y)
}
find.pos <-
function(y, inn)
{
#
# Finds positions of "y" in a vector "inn"
    x <- match(inn, y)
    seq(along = x)[!is.na(x)]
}
find.pos.mat <-
function(mat = b, test = (b > 1))
{
# Finds positions in matrix of elements which meet test
    want <- mat[test]
    if(length(want) == 0)
       cat("No matches\n")
    else pass <- cbind(row(mat)[test], col(mat)[test])
    dimnames(pass) <- list(paste("Soln:", 1:dim(pass)[1], sep = ""), c("Row", 
       "Col"))
    pass
}
fitconf <-
function(link = "cloglog", mins, dead, tot, cutoff = NULL, offset, j, leg, 
    interval = F, pc = c(line = 50, line = 99), pc.spline = NULL, pc.monotone
     = c(line = 50, line = 99), span.mono = 1, plot.spline = F, plot.monotone
     = NULL, cutoff.mono = 0, xfun = function(x)
x, cm = NULL, numcm = NULL, p.min = NULL, printdat = F, save.resid = F, 
    cm.strategy = "adjust.later", cm.code = 0, cm.allcodes = NULL, xfun.inv = 
    NULL, full.robust = T)
{
# link is link function for binomial model
# mins is time of sampling
# dead is number of dead
# total is total number
# cutoff - data at less than this time are not included in the fitting
# offset is the amount added to time to improve linearity
# j is the dataset index number
# log time is used in calculations
# calculations are done using mean zero data
#
# nmid is the number of points suitable for fitting
    if(is.null(xfun.inv)) xfun.inv <- function(x)
       x
    if(all(xfun(exp(1:5)) == (1:5))) {
       takelog <- T
       xfun.inv <- exp
    }
    else takelog <- F
    if(all(xfun(1:8) == (1:8)))
       xfun.inv <- function(x)
       x
    if(all(xfun(1:8) == (1:8)^2)) xfun.inv <- sqrt    
    #	link choices are "identity", "log", "logsurv", "logit", "sqrt", 
#               "inverse", "probit", "cloglog", "loglog"
    inv.fun <- link.inverse(link)    # get inverse of link function
    link.fun <- link.function(link)    # get link function
    if(any(dead > tot))
       stop(paste("\none or more totals is less than no of dead\n", "Dead:", 
          paste(dead, collapse = " "), "\nTotal:", paste(tot, collapse = " ")))
    mins <- as.character(mins)
    cmrows <- mins == cm.code[1]
    if(sum(cmrows) == 0 & length(cm.code) > 1) {
       cmrows <- mins == cm.code[2]
       second.cm <- T
    }
    else second.cm <- F
    x.all <- array(, length(mins))
    x.all <- array(, length(mins))
    x.all[cmrows] <-  - Inf
    cutit <- !cmrows & tot > 0
    if(!is.null(cm.allcodes)) {
       other.rows <- as.logical(match(mins, cm.allcodes, nomatch = 0))
       if(any(other.rows))
          cutit[other.rows] <- F
       x.all[!cutit & !cmrows] <- NA
       x.cm <- mins[other.rows]
       dead.cm <- dead[other.rows]
       tot.cm <- tot[other.rows]
    }
    else x.cm <- NULL
    interp.rows <- cutit | mins == "0"
    if(is.null(cutoff.mono))
       cutoff.mono <- min(c(0, x.all[cutit]))
    mono.rows <- cutit | mins == "0"
    x.all[mono.rows] <- as.numeric(mins[mono.rows])
    if(any(is.na(x.all[cutit])))
       stop(paste("Illegal code", mins[cutit][is.na(x.all[cutit])], 
          "has appeared."))
    mono.rows[mono.rows][x.all[mono.rows] < cutoff.mono] <- F
    if(!is.null(pc.monotone) | !is.null(plot.monotone))
       monospeak <- paste("Monotone fit: Include x >= ", cutoff.mono, ":", sep
           = "")
    else monospeak <- ""
    if(!is.null(cutoff)) {
       cutit[cutit] <- x.all[cutit] >= cutoff
       cutspeak <- paste("Line: Include x >= ", cutoff, ":", sep = "")
    }
    else cutspeak <- ""
    if(!is.null(p.min)) {
       p <- dead/tot
       omitspeak <- paste("Omit until p > ", format(round(p.min, 2)), ":", sep
           = "")
       testseq <- seq(along = x.all)[p < p.min]
       if(length(testseq) > 0)
          omit <- 1:max(testseq)
       else omit <- 0
    }
    else {
       omit <- 0
       omitspeak <- ""
    }
    cat("\n", j, "  ", leg, fill = T)
    cutit[omit] <- F
    if(is.null(numcm)) numcm <- 0    # numcm may be reset below
    if(!is.null(cm)) {
       if(numcm == 0)
          cmspeak <- paste("   cm (taken as fixed) =")
       else cmspeak <- "  cm (supplied) ="
       cmspeak <- paste(cmspeak, format(round(cm, 3)))
    }
    else {
       if(sum(cmrows) > 0) {
          if(any(x.all[cmrows] !=  - Inf & x.all[cmrows] != 0))
             cat("\n*** Warning: Fault in specification of cm rows ***", "\n")
          dead0 <- sum(dead[cmrows])
          tot0 <- sum(tot[cmrows])
          cm <- dead0/tot0
          numcm <- tot0
          n.cm <- sum(cmrows)
          cmspeak <- paste("   cm(obs) =", format(round(cm, 3)), "(from", n.cm,
             paste("point", switch((n.cm > 1) + 1,
             "",
             "s",
             ), ")", sep = ""))
          if(second.cm)
             cmspeak <- paste(cmspeak, "  cm code (2nd choice) =", cm.code[2])
       }
       else cmspeak <- "No information is available on cm"
    }
    if(!is.null(pc.spline)) {
       pfrac.interp <- pc.spline/100
       yhat.pred <- link.fun(pfrac.interp)
       dead.interp <- dead[interp.rows]
       tot.interp <- tot[interp.rows]
       p.obs <- (dead.interp/tot.interp)
       time.interp <- as.numeric(mins[interp.rows])
       time1 <- max(time.interp[p.obs == 0])
       if(is.na(time1))
          time1 <- min(time.interp)
       time2 <- min(time.interp[p.obs == 1])
       if(is.na(time2))
          time2 <- max(time.interp)
       time.here <- (time.interp >= time1) & (time.interp <= time2)
       dead.interp <- dead.interp[time.here]
       tot.interp <- tot.interp[time.here]
       p.interp <- (dead.interp + 1/6)/(tot.interp + 1/3)
       x.interp <- time.interp[time.here]
    }
##
    if(!is.null(pc.monotone)) {
       time.here <- as.numeric(mins[mono.rows])
       ord.x <- order(time.here)
       subs.here <- (1:length(mono.rows))[mono.rows][ord.x]
       dead.mono <- dead[subs.here]
       tot.mono <- tot[subs.here]
       p.obs <- (dead.mono/tot.mono)
       time.mono <- time.here[ord.x]
    }
##
    ld.dp <- 2 - floor(log(max(x.all[cutit], na.rm = T))/log(10))
    ld.dp <- max(0, ld.dp)
    if(is.na(ld.dp))
       ld.dp <- 1
    if(nchar(monospeak) > 0)
       cat(monospeak, "\n")
    if(nchar(cutspeak) + nchar(omitspeak) > 0)
       cat(cutspeak, " ", omitspeak)
    cat(sum(cutit), "points remain_")
    cat(cmspeak, "\n")
    if(takelog) {
       x.trt <- log(x.all[cutit] + offset)
    }
    else {
       x.trt <- xfun(x.all[cutit] + offset)
    }
    xbar <- mean(x.trt)
    x.explan <- x.trt - xbar
    dead2 <- dead[cutit]
    tot2 <- tot[cutit]
    nmid <- length(x.trt[dead2 < tot2])
    lt <- rep(-999, length(pc))
    b0 <- -999
    b1 <- -999
    selog50 <- -999
    selog99 <- -999
    cept <- NA
    dev <- NA
    df <- NA
    dev.robust <- NA
    df.robust <- NA
    disp <- NA
    resid <- NULL
    resid.dev <- NULL
    lt.se <- rep(NA, length(pc))
    cm.est <- cm
    cm.n <- c(cm, numcm)
    if(!is.null(pc.monotone) && (length(time.mono) >= 2)) {
       if(link == "loglog")
          link <- "cloglog"
       lt.monotone <- pool.adj(time.mono, dead.mono, tot.mono, phat = 
          pc.monotone, cm = cm, cm.strategy = cm.strategy, cm.allcodes = 
          cm.allcodes, plotit = plot.monotone, link = link, xfun = xfun, legend
           = leg, x.cm = x.cm, dead.cm = dead.cm, tot.cm = tot.cm, span = 
          span.mono)
       note <- c("( loess)", "( monotone line)")[names(lt.monotone)]
       cat(paste("   LT", pc.monotone, ":", format(round(lt.monotone, ld.dp)), 
          sep = ""), note, "\n")
    }
    else lt.monotone <- NULL
    if(!is.null(pc.spline)) {
       lt.spline <- interp.curve(x.interp, p = p.interp, pval = pfrac.interp, 
          plot.interp = plot.spline, fun = link.fun)
       cat(paste("   LT", pc.spline, ":",  , sep = ""), format(round(lt.spline,
          ld.dp)), "(spline)   ", "\n")
    }
    else lt.spline <- NULL
    if(nmid == 2)
       full.robust <- F
    if(nmid >= 2) {
       u <- likelihood.ci(cm.n = cm.n, x.explan, xbar, dead2, tot2, link = link,
          xfun.inv = xfun.inv, interval = interval, pc = pc, save.resid = 
          save.resid, cm.strategy = cm.strategy, full.robust = full.robust)
       lt <- u$ld
       ld.dp <- 2 - floor(log(lt[length(lt)])/log(10))
       if(is.na(ld.dp))
          ld.dp <- 1
       ld.dp <- max(ld.dp, 0)
       b0 <- u$coef[1]
       b1 <- u$coef[2]
       cept <- b0 - b1 * xbar
       lt.se <- u$selog
       resid <- u$resid
       resid.dev <- u$resid.dev
       dev <- u$dev
       df <- u$df
       dev.robust <- u$dev.robust
       df.robust <- u$df.robust
       disp <- u$dispersion
       linpred <- b0 + b1 * x.explan    #		comprob <- inv.fun(linpred)
#		fitr <- (1 - comprob) * tot2
#		fitc <- comprob * tot2
       if(printdat) print(cbind(x.all[cutit], dead2, tot2))    
    #			print(cbind(x.all[cutit], x.explan, fitr, dead2, tot2))
#		if(min(fitr) < 1) {
#			cat("Warning.  Some expected numbers 0f dead are < 1", 
#				fill = T)
#			cat("Exp. No. Dead:", format(round(fitr, 3)), fill = T)
#			
#		}
#		if(min(fitc) < 1) {
#			cat(
#				"Warning.  Some expected numbers of survivors are < 1", 
#				fill = T)
#			cat("Exp. Survivors   :", format(round(fitc, 3)), fill
#				 = T)
#		}
    }
    else {
# Estimates of LT50 and LT90 when too few data points are available
#
       if(printdat) print(cbind(x.all, dead, tot, cutit))
       cat(nmid, " data points give mortalities < 1.0:     ")
       lt <- NA
       cat("No estimate is available", "\n")
    }
    if(!save.resid) tot2 <- NULL    
    # Keep totals only if required along with residual information 
    list(lt = lt, se = lt.se, b0 = cept, b1 = b1, lt.spline = lt.spline, 
       lt.monotone = lt.monotone, cm = cm.est, dev = dev, df = df, dev.robust
        = dev.robust, df.robust = df.robust, dispersion = disp, total = tot2, 
       resid = resid, resid.dev = resid.dev, times = x.trt)
}
flex.contour <-
function(df = cont.test.df[1:273, (1:3)], transpose = F, label.pos = (13:18)/20,
    levs.pc = c(50, 75, 90, 95, 99), lev.cex = 0.59999999999999998, lev.font = 
    1, mark = F, alone = F, ztransform = "logit")
{
# Flexibility in positioning the contour-level labels is the name of the game.
#
# df is dataframe such as produced by gee.
# Requires also is.not.na() in Gems & make.line.loess()
# Not generic yet. Uses only logit transformed % data
    xxs <- unique(df[, 1])
    yys <- unique(df[, 2])
    zzs <- df[, 3]
    zzs.mat <- matrix(zzs, nr = length(is.not.na(xxs)))
    x.use <- iff(transpose, yys, xxs)
    y.use <- iff(transpose, xxs, yys)
    if(transpose)
       zzs.mat <- t(zzs.mat)
    ztransform.fn <- get(ztransform)
    lev.pos <- ztransform.fn(levs.pc/100)    # (levs.pc are percentages)
    lev.txt <- paste(levs.pc)
    cont.fit <- contour(x.use, y.use, zzs.mat, save = T, levels = lev.pos)
    if(alone)
       plot(range(x.use), range(y.use), type = "n")
    if(length(label.pos < length(levs.pc)))
       label.pos <- rep(label.pos, length(levs.pc))
    for(i in 1:length(cont.fit)) {
       make.line.loess(cont.fit[[i]], lab = lev.txt[i], mark = mark, label.pos
           = label.pos[i], cex = lev.cex, lev.font = lev.font)
    }
}
flyplot <-
function(mn = 1:12, ri = 3, cj = 4, line = T, cutoff.mono = NULL, data = NULL, 
    datafun = NULL, choice = 1, plimits = c(0.10000000000000001, 
    0.99950000000000006), link = "cloglog", range.strategy = "page", fit.trend
     = "line", pc = c(line = 50, line = 99), span.mono = 1, n.strategy = "mn", 
    xlabels = NULL, xfun = function(x)
x, takelog = F, before = NA, new.page = T, mkh = 0.025000000000000001, cex = 
    NULL, maint.line = 1, title.line = 0.25, title.space = 0, xtitle = NULL, 
    ytitle = NULL, ext = NULL, lt.ld = "LT", datestamp = T, byrow = T, 
    mtext.line = 2)
{
### Title for data subset j is maint
### Prints graphs 4 to a page, starting with graph for data subset j=i
### dset holds all the data
### values of idset (1, 2, ...) identify subsets of dset
### range.strategy may be "individual", or "page", or "all"
### fit.trend may be line, or mono(tone), or mono.line
### mono.line gives monotone fit, then line
### Set pc to decide which LTs will appear on the margin of the plot.
##
    options(width = 200)
    on.exit(options(width = 80))
    trend.4 <- substring(fit.trend, 1, 4)
    do.abers <- trend.4 == "mono" | trend.4 == "loes"
    oldpar <- par()
    on.exit(par(oldpar), T)    #
# Set up different par parameters for postscript and motif devices.
    if(names(dev.cur()) == "postscript") {
       omi <- c(8, 20 + title.space/3, 7 + title.space, 25 + title.space/3)/
          25.399999999999999
       mgp <- c(1.75, 0.69999999999999996, 0)
       mai <- c(18, 20, 12, 5)/25.399999999999999
    }
    else {
       omi <- c(5, 5 + title.space/3, 7 + title.space, 10 + title.space/3)/
          25.399999999999999
       mgp <- c(2.25, 1, 0)
       mai <- c(15, 20, 10, 0)/25.399999999999999
    }
    if(new.page & byrow)
       par(mai = mai, mgp = mgp, mfrow = c(ri, cj), omi = omi)
    else if(new.page & !byrow)
       par(mai = mai, mgp = mgp, mfcol = c(ri, cj), omi = omi)
    if(is.null(cex) & (ri * cj == 6))
       cex <- 0.65000000000000002
    if(!is.null(cex))
       par(cex = cex)
    final.choice <- choice[length(choice)]
    if(!is.null(data)) {
       ab <- data[[final.choice]]
       leg.ab <- ab$leg.brief
       if(is.null(leg.ab))
          leg.ab <- ab$legend
       choice.call <- ab$choice
       if(missing(takelog) & missing(xfun)) {
          takelog <- ab$takelog
          if(takelog)
             xfun <- log
       }
    }
    else {
       ab <- NULL
       leg.ab <- NULL
       choice.call <- choice
    }
    if(missing(datafun) & !is.null(ab))
       datafun <- get(ab$datafun)
    if(!is.null(ext))
       u <- datafun(choice.call, ext = ext)
    else u <- datafun(choice.call)
    if(is.null(leg.ab))
       leg.ab <- u$leg.brief
    if(!is.null(pc)) {
       lt.txts <- paste(pc)
       lt.prefix <- paste(lt.ld, pc, "=", sep = "")
       lt.strategy <- names(pc)
    }
    else {
       lt.strategy <- NULL
       lt.txts <- NULL
    }
    if(missing(ext))
       ext <- NULL
    if(!is.null(ab) & !is.null(lt.strategy)) {
       first.one <- switch(lt.strategy[1],
          loess = ,
          monotone = ,
          mono = "lt.monotone",
          line = "lt")
       ltmat.leg <- matrix(, dim(ab[[first.one]])[1], length(pc))
       for(k in seq(along = lt.strategy)) {
          which.lt <- switch(lt.strategy[k],
             loess = ,
             monotone = ,
             mono = "lt.monotone",
             line = "lt")
          ltmat.leg[, k] <- ab[[which.lt]][, lt.txts[k]]
       }
       dp <- max(c(3 - ceiling(log(quantile(ab[[first.one]], probs = 0.75, 
          na.rm = T))/log(10)), 0))
    }
    else ltmat.leg <- NULL
    if(!is.null(ltmat.leg)) {
       if(is.null(leg.ab))
          leg.ab <- rep("", dim(ltmat.leg)[1])
       leg.lt <- apply(ltmat.leg, 1, function(x, z, u, dp)
       paste(z, round(x, dp), collapse = "; "), z = lt.prefix, dp = dp)
       legend <- paste(leg.ab, " [", leg.lt, "]", sep = "")
    }
    else if(!is.null(leg.ab))
       legend <- leg.ab
    else if(length(lt.txts) > 0)
       cat(paste(paste("LT", lt.txts, sep = " "), collapse = ""), 
          "values are not available, perhaps because pc was not given correctly\n"
          )
    cutx <- u$cutx
    offset <- u$offset
    cm <- NULL
    if(!is.null(ab)) {
       cm.code <- ab$cm.code
       cm <- ab$cm
       cm.strategy <- ab$cm.strategy
       cmtot <- u$cmtot
    }
    else {
       cm.code <- u$cm.code
       cm <- u$cm
       cmtot <- u$cmtot
       cm.strategy <- u$cm.strategy
    }
    if(is.null(cm.strategy))
       cm.strategy <- "adjust.later"
    if(is.null(cm.code))
       cm.code <- 0
    cm.allcodes <- u$cm.allcodes
    if(is.null(cm.allcodes))
       cm.allcodes <- cm.code
    times.all <- as.character(u$time)
    tot.all <- u$tot
    other.rows <- as.logical(match(times.all, cm.allcodes, nomatch = 0))
    keep <- rep(T, length(other.rows))
    if(any(is.na(as.numeric(times.all[!other.rows])))) {
       cat("\n*** NA(s) appear among non-control times ***\n")
       numit <- times.all[!other.rows]
       look <- is.na(as.numeric(numit))
       print(data.frame(times = numit[look], totals = tot.all[!other.rows][look
          ], dead = u$dead[!other.rows][look]))
       keep[!other.rows][look] <- F
    }
    if(any(is.na(tot.all) | tot.all == 0)) {
       look <- is.na(tot.all) | tot.all == 0
       cat("\nNAs or zeros appear among totals\n")
       print(data.frame(times = times.all[look], total = tot.all[look], dead = 
          u$dead[look]))
       keep[look] <- F
    }
    time.txt <- times.all[keep]
    times <- array( - Inf, length(time.txt))
    use.trt <- !other.rows[keep] | time.txt == "0"
    times[use.trt] <- as.numeric(time.txt[use.trt])
    xmin <- min(times[use.trt])
    idset <- u$id[keep]
    tot <- u$total[keep]
    dead <- u$dead[keep]
    if(missing(xtitle))
       xaxtitle <- u$xaxtitle
    else xaxtitle <- xtitle
    treat <- u$treat
    maint <- u$maint
    if(is.null(xlabels))
       xxlabels <- u$xlabels
    else xxlabels <- xlabels
    nu <- unique(idset)
    nn <- match(nu, idset)    #	bigstage <- dset[, stagecol]
    n <- ri * cj
    if(max(mn) > length(nu)) {
       maxj <- length(nu)
       cat("You have specified plots up to plot no.", max(mn), 
          "\nwhereas data is available for", maxj, "plots only.\n")
       mn <- mn[mn <= maxj]
    }
    graphnum <- mn
    maxj <- max(mn)
    if(range.strategy != "individual")
       common.range <- switch(range.strategy,
          page = mn,
          all = 1:length(nu))
    todo <- length(nu) - maxj
    if(todo > 0)
       cat("Datasets", maxj + 1, "to", length(nu), "will remain after this.", 
          fill = T)
    xmin <- min(times)
    if(takelog)
       xmin <- min(times[times + offset > 0])
    xrange <- switch(cm.strategy,
       adjust.later = range(times),
       abbott = range(times))
    ij <- 0
    if(range.strategy != "individual") {
       xrm <- matrix(, 2, length(common.range))
       for(k in common.range) {
          ij <- ij + 1
          timtim <- times[idset == nu[k]]
          xrm[, ij] <- switch(cm.strategy,
             adjust.later = range(timtim),
             abbott = range(timtim))
       }
       xrange <- range(xrm)
    }
    if(!missing(before))
       xrange[2] <- before
    ij <- 0
    cmk <- NULL
    for(k in graphnum) {
       leg.k <- legend[k]
       ij <- ij + 1
       j <- nu[k]
       take <- idset == j
       timesj <- times[take]
       deadj <- dead[take]
       totj <- tot[take]
       time.txj <- time.txt[take]
       cmrows <- time.txj == cm.code[1]
       second.cm <- F
       if(sum(cmrows) == 0 & length(cm.code) > 1) {
          cmrows <- time.txj == cm.code[2]
          second.cm <- T
       }
       else second.cm <- F
       if(!is.null(cmtot))
          numcm <- cmtot[k]
       else numcm <- NULL
       if(is.null(numcm)) numcm <- 0    # numcm may be reset below
       if(is.null(cm)) {
          if(sum(cmrows) > 0) {
             if(any(timesj[cmrows] !=  - Inf & timesj[cmrows] != 0))
                cat("\n*** Warning: Fault in specification of cm rows ***", 
                   "\n")
             dead0 <- sum(deadj[cmrows])
             tot0 <- sum(totj[cmrows])
             cmk <- dead0/tot0
             numcm <- tot0
             n.cm <- sum(cmrows)
             cmspeak <- paste("   cm(obs) =", format(round(cm, 3)), "(from", 
                n.cm, paste("point", switch((n.cm > 1) + 1,
                "",
                "s",
                ), ")", sep = ""))
             if(second.cm)
                cmspeak <- paste(cmspeak, "  cm code (2nd choice) =", cm.code[2
                   ])
          }
          else cmspeak <- "No information is available on cm"
       }
       else {
# !is.null(cm)
          cmk <- cm[k]
          if(cm.strategy == "abbott") {
             cat("Take cm =", format(round(cmk, 3)), "\n")
             take <- take & !other.rows
          }
       }
       if(do.abers) {
          use.mono <- use.trt[take]
          if(!is.null(cutoff.mono))
             use.mono[timesj[use.mono] < cutoff.mono] <- F
          time.here <- timesj[use.mono]
          ord.x <- order(time.here)
          subs.here <- (1:length(use.mono))[use.mono][ord.x]
          dead.mono <- deadj[subs.here]
          tot.mono <- totj[subs.here]
          p.mono <- (dead.mono/tot.mono)
          time.mono <- time.here[ord.x]
          other.take <- other.rows[take]
          x.cm <- time.txt[take][other.take]
          dead.cm <- deadj[other.take]
          tot.cm <- totj[other.take]
          if(length(time.mono) < 2)
             do.abers <- F
       }
       if(do.abers) {
          if(link == "loglog")
             link <- "cloglog"
          lt.mono <- pool.adj(time.mono, dead.mono, tot.mono, phat = NULL, cm
              = cmk, cm.strategy = cm.strategy, cm.allcodes = cm.allcodes, 
             plimits = plimits, xtit = xaxtitle, plotit = fit.trend, link = 
             link, xfun = xfun, legend = leg.k, x.cm = x.cm, dead.cm = dead.cm,
             tot.cm = tot.cm, span = span.mono)
       }
       if(range.strategy == "individual")
          xrange <- switch(cm.strategy,
             adjust.later = ,
             abbott = range(times[take]))
       if(diff(range(xxlabels)) > 0)
          xlabels <- xxlabels
       else xlabels <- pretty(range(times[take]))
       if(line) {
          ltab <- ab
          b <- ltab[["slope"]][k]
          a <- ltab[["intercept"]][k]
       }
       else {
          a <- -999
          b <- -999
       }
       startx <- max(xmin, cutx[k])
       jk <- switch(n.strategy,
          id = j,
          mn = k)
       if(!do.abers) {
          simplot(time.txt[take], deadj, totj, link, cm = cmk, cm.strategy = 
             cm.strategy, xtit = xaxtitle, ytit = ytitle, main = paste(jk, ": ",
             " ", leg.k, sep = ""), xfun = xfun, takelog = takelog, line = line,
             ab = c(a, b), clip = c(startx, max(timesj)), xlimits = xrange, 
             xlabels = xlabels, offset = offset, plimits = plimits, mkh = mkh, 
             title.line = title.line, id = NULL)
       }
       if(names(dev.cur()) == "postscript" & nchar(maint) > 0)
          mixed.mtext(texts = maint, side = 3, outer = T, cex = 1.25, line = 
             maint.line, adj = 0.5)
       else mtext(maint, 3, outer = T, cex = 1.3500000000000001, line = 
             maint.line)
    }
    if(cm.strategy == "abbott")
       mtext("Data is plotted following Abott's adjustment", 3, line = 
          maint.line - 1, outer = T, cex = 0.5)
    lt.leg <- paste(paste("lt", pc, ":", names(pc), sep = ""), collapse = "; ")
    par(cex = 0.40000000000000002)
    r.txt <- paste(lt.leg, "   ", unix("date +%d/%m/%y'  '%H:%M"))
    l.txt <- paste(unix("pwd"), as.character(as.name(match.call())), collapse
        = "")
    if(datestamp) {
       mtext(r.txt, side = 1, adj = 1, outer = T, line = mtext.line)
       mtext(l.txt, side = 1, adj = 0, outer = T, line = mtext.line)
    }
}
formula.variables <-
function(myformula, unwanted = NULL)
{
    ops <- c("~", "+", "-", "*", "|", "I", "(", ")", "sqrt", "log", "exp", 
       "logit", "cloglog", "ang", unwanted)
    out <- unlist(myformula)
    out[!(out %in% ops)]
}
gen.write <-
function(df, file)
{
#To create a file readable by genstat from a dataframe
#
    write.table(df, file, sep = "  ", na = "*", dimnames.write = F)
}
get.col.names <-
function(x, patt = ".D")
{
# Gets the names of x that fit a particular pattern patt
    col.names <- names(x)
    y <- col.names[grep(patt, col.names)]
}
get.formula <-
function(ab.list = ab.second.comb, bit = "cs", link = "cloglog", rnd = 4)
{
# Gets the formula for lines from ab list
    ab <- ab.list[[paste(bit)]]
    legends <- ab$legend
    glean <- get(ab$datafun)
    cat(glean()$maint)
    cat("\n\n")
    out.list <- list()
    for(i in 1:len(legends))
       out.list[[ab$legend[i]]] <- ppaste(link, "(p) = ", round(ab$intercept[i],
          rnd), " + ", round(ab$slope[i], rnd), " * t")
    out.list
}
get.mort.tables <-
function(ab.list = ab.second.comb, bit = "cs", intervals = NULL, rnd = 4, file
     = "")
{
# Does table of expected mortality for lines from ab list
    ab <- ab.list[[paste(bit)]]
    legends <- ab$legend
    glean <- get(ab$datafun)
    cat(glean(choice = bit)$maint)    # browser()
    cat("\n\n")
    if(is.null(intervals))
       intervals <- seq(0, round(max(glean(choice = bit)$time)))
    out.list <- list(times = intervals)
    for(i in 1:len(legends))
       out.list[[ab$legend[i]]] <- round(cloglog.bt(ab$intercept[i] + ab$slope[
          i] * intervals) * 100, 1)
    out.df <- as.data.frame(out.list)
    if(file != "") {
       write(glean(choice = bit)$maint, file = file)
       df.to.file(out.df, file = file, append = T)
    }
    else out.df
}
glean.blank <-
function(choice = 1)
{
    blank.df <- df.sort(blank.df, rev(c("Stage", "Position", "Rep")))
    attach(blank.df)
    on.exit(detach("blank.df"))
    idset <- make.id(Time)
    cutx <- NULL
    leg.brief <- unique(paste(Stage, Position, " Rep", Rep, sep = ""))
    maint <- paste(degree(40), "heat treatment of some bug or other")
    xlabels <- c(0, 0)
    xaxtitle <- "Time (minutes)"
    list(id = idset, times = Time, total = Dead + Live, dead = Dead, cutx = 
       cutx, offset = 0, xaxtitle = xaxtitle, maint = maint, legend = leg.brief,
       xlabels = xlabels, takelog = F)
}
graph.paper <-
function(mn = 1, ri = 1, cj = 1, line = F, cutoff.mono = NULL, data = ab.poster,
    datafun = NULL, choice = 3, plimits = c(0.0080000000000000002, 
    0.99950000000000006), link = "loglog", range.strategy = "page", fit.trend
     = "line", pc = c(line = 50, line = 99), span.mono = 1, n.strategy = "mn", 
    xfun = function(x)
x, takelog = F, before = NA, new.page = T, mkh = 0.025000000000000001, cex = 
    NULL, maint.line = 1, title.line = 0.25, xtitle = NULL, ytitle = NULL, ext
     = NULL, lt.ld = "LT", datestamp = F, byrow = T, mtext.line = 0, lwd = 1, 
    xpos = c(0:10))
{
# WARNING: Not generally useful: tinkered with for /diana/dcw.mly.paper96 directory
#
# Calls simplot.t  which has had lots of tinkering to draw graph paper only
#	
### fit.trend may be line, or mono(tone), or mono.line
### mono.line gives monotone fit, then line
### Set pc to decide which LTs will appear on the margin of the plot.
##
#
# Use split.screen to fix up borders
#
# First set up screen splits
#	file <- "Graph.pad.ps"
#	postscript(file = file, horizontal = T)
#	on.exit(dev.off(), add = T)	#	
# Set margins for the single screen
    m <- par()$mai    #
    m[1] <- 15/25.399999999999999
    m[2] <- 15/25.399999999999999
    m[3] <- 1/25.399999999999999
    m[4] <- 15/25.399999999999999
    par(mai = m)
    screens <- split.screen(c(1, 1), erase = T)
    screen(screens[1], new = T)
    par(mai = m)
    screen(screens[1], new = F)
    trend.4 <- substring(fit.trend, 1, 4)
    do.abers <- trend.4 == "mono" | trend.4 == "loes"
    oldpar <- par()
    on.exit(par(oldpar), T)
    if(names(dev.cur()) == "postscript" & cj * ri > 6)
       par(mar = par()$mar + c(-2, 0, 0, 0))
    if(is.null(cex) & (ri * cj == 6))
       cex <- 0.65000000000000002
    if(!is.null(cex))
       par(cex = cex)
    final.choice <- choice[length(choice)]
    if(!is.null(data)) {
       ab <- data[[final.choice]]
       leg.ab <- ab$leg.brief
       if(is.null(leg.ab))
          leg.ab <- ab$legend
       choice.call <- ab$choice
       if(missing(takelog) & missing(xfun)) {
          takelog <- F
          if(takelog)
             xfun <- log
       }
       xfun <- function(x)
       x
    }
    else {
       ab <- NULL
       leg.ab <- NULL
       choice.call <- choice
    }
    if(missing(datafun) & !is.null(ab))
       datafun <- get(ab$datafun)
    if(!is.null(ext))
       u <- datafun(choice.call, ext = ext)
    else u <- datafun(choice.call)
    if(is.null(leg.ab))
       leg.ab <- u$leg.brief
    if(!is.null(pc)) {
       lt.txts <- paste(pc)
       lt.prefix <- paste(lt.ld, pc, "=", sep = "")
       lt.strategy <- names(pc)
    }
    else {
       lt.strategy <- NULL
       lt.txts <- NULL
    }
    if(missing(ext))
       ext <- NULL
    if(!is.null(ab) & !is.null(lt.strategy)) {
       first.one <- switch(lt.strategy[1],
          loess = ,
          monotone = ,
          mono = "lt.monotone",
          line = "lt")
       ltmat.leg <- matrix(, dim(ab[[first.one]])[1], length(pc))
       for(k in seq(along = lt.strategy)) {
          which.lt <- switch(lt.strategy[k],
             loess = ,
             monotone = ,
             mono = "lt.monotone",
             line = "lt")
          ltmat.leg[, k] <- ab[[which.lt]][, lt.txts[k]]
       }
       dp <- max(c(3 - ceiling(log(quantile(ab[[first.one]], probs = 0.75, 
          na.rm = T))/log(10)), 0))
    }
    else ltmat.leg <- NULL
    if(!is.null(ltmat.leg)) {
       if(is.null(leg.ab))
          leg.ab <- rep("", dim(ltmat.leg)[1])
       leg.lt <- apply(ltmat.leg, 1, function(x, z, u, dp)
       paste(z, round(x, dp), collapse = "; "), z = lt.prefix, dp = dp)
       legend <- paste(leg.ab, " [", leg.lt, "]", sep = "")
    }
    else if(!is.null(leg.ab))
       legend <- leg.ab
    else if(length(lt.txts) > 0)
       cat(paste(paste("LT", lt.txts, sep = " "), collapse = ""), 
          "values are not available, perhaps because pc was not given correctly\n"
          )
    cutx <- u$cutx
    offset <- u$offset
    cm <- NULL
    if(!is.null(ab)) {
       cm.code <- ab$cm.code
       cm <- ab$cm
       cm.strategy <- ab$cm.strategy
       cmtot <- u$cmtot
    }
    else {
       cm.code <- u$cm.code
       cm <- u$cm
       cmtot <- u$cmtot
       cm.strategy <- u$cm.strategy
    }
    if(is.null(cm.strategy))
       cm.strategy <- "adjust.later"
    if(is.null(cm.code))
       cm.code <- 0
    cm.allcodes <- u$cm.allcodes
    if(is.null(cm.allcodes))
       cm.allcodes <- cm.code
    times.all <- as.character(u$time)
    tot.all <- u$tot
    other.rows <- as.logical(match(times.all, cm.allcodes, nomatch = 0))
    keep <- rep(T, length(other.rows))
    if(any(is.na(as.numeric(times.all[!other.rows])))) {
       cat("\n*** NA(s) appear among non-control times ***\n")
       numit <- times.all[!other.rows]
       look <- is.na(as.numeric(numit))
       print(data.frame(times = numit[look], totals = tot.all[!other.rows][look
          ], dead = u$dead[!other.rows][look]))
       keep[!other.rows][look] <- F
    }
    if(any(is.na(tot.all) | tot.all == 0)) {
       look <- is.na(tot.all) | tot.all == 0
       cat("\nNAs or zeros appear among totals\n")
       print(data.frame(times = times.all[look], total = tot.all[look], dead = 
          u$dead[look]))
       keep[look] <- F
    }
    time.txt <- times.all[keep]
    times <- array( - Inf, length(time.txt))
    use.trt <- !other.rows[keep] | time.txt == "0"
    times[use.trt] <- as.numeric(time.txt[use.trt])
    xmin <- min(times[use.trt])
    idset <- u$id[keep]
    tot <- u$total[keep]
    dead <- u$dead[keep]
    if(missing(xtitle))
       xaxtitle <- u$xaxtitle
    else xaxtitle <- xtitle
    treat <- u$treat
    maint <- u$maint
    xxlabels <- u$xlabels
    nu <- unique(idset)
    nn <- match(nu, idset)    #	bigstage <- dset[, stagecol]
    n <- ri * cj
    if(max(mn) > length(nu)) {
       maxj <- length(nu)
       cat("You have specified plots up to plot no.", max(mn), 
          "\nwhereas data is available for", maxj, "plots only.\n")
       mn <- mn[mn <= maxj]
    }
    graphnum <- mn
    maxj <- max(mn)
    if(range.strategy != "individual")
       common.range <- switch(range.strategy,
          page = mn,
          all = 1:length(nu))
    todo <- length(nu) - maxj
    if(todo > 0)
       cat("Datasets", maxj + 1, "to", length(nu), "will remain after this.", 
          fill = T)
    xmin <- min(times)
    if(takelog)
       xmin <- min(times[times + offset > 0])
    xrange <- switch(cm.strategy,
       adjust.later = range(times),
       abbott = range(times))
    ij <- 0
    if(range.strategy != "individual") {
       xrm <- matrix(, 2, length(common.range))
       for(k in common.range) {
          ij <- ij + 1
          timtim <- times[idset == nu[k]]
          xrm[, ij] <- switch(cm.strategy,
             adjust.later = range(timtim),
             abbott = range(timtim))
       }
       xrange <- range(xrm)
    }
    if(!missing(before))
       xrange[2] <- before
    ij <- 0
    cmk <- NULL
    for(k in graphnum) {
       leg.k <- legend[k]
       ij <- ij + 1
       j <- nu[k]
       take <- idset == j
       timesj <- times[take]
       deadj <- dead[take]
       totj <- tot[take]
       time.txj <- time.txt[take]
       cmrows <- time.txj == cm.code[1]
       second.cm <- F
       if(sum(cmrows) == 0 & length(cm.code) > 1) {
          cmrows <- time.txj == cm.code[2]
          second.cm <- T
       }
       else second.cm <- F
       if(!is.null(cmtot))
          numcm <- cmtot[k]
       else numcm <- NULL
       if(is.null(numcm)) numcm <- 0    # numcm may be reset below
       if(is.null(cm)) {
          if(sum(cmrows) > 0) {
             if(any(timesj[cmrows] !=  - Inf & timesj[cmrows] != 0))
                cat("\n*** Warning: Fault in specification of cm rows ***", 
                   "\n")
             dead0 <- sum(deadj[cmrows])
             tot0 <- sum(totj[cmrows])
             cmk <- dead0/tot0
             numcm <- tot0
             n.cm <- sum(cmrows)
             cmspeak <- paste("   cm(obs) =", format(round(cm, 3)), "(from", 
                n.cm, paste("point", switch((n.cm > 1) + 1,
                "",
                "s",
                ), ")", sep = ""))
             if(second.cm)
                cmspeak <- paste(cmspeak, "  cm code (2nd choice) =", cm.code[2
                   ])
          }
          else cmspeak <- "No information is available on cm"
       }
       else {
# !is.null(cm)
          cmk <- cm[k]
          if(cm.strategy == "abbott") {
             cat("Take cm =", format(round(cmk, 3)), "\n")
             take <- take & !other.rows
          }
       }
       if(do.abers) {
          use.mono <- use.trt[take]
          if(!is.null(cutoff.mono))
             use.mono[timesj[use.mono] < cutoff.mono] <- F
          time.here <- timesj[use.mono]
          ord.x <- order(time.here)
          subs.here <- (1:length(use.mono))[use.mono][ord.x]
          dead.mono <- deadj[subs.here]
          tot.mono <- totj[subs.here]
          p.mono <- (dead.mono/tot.mono)
          time.mono <- time.here[ord.x]
          other.take <- other.rows[take]
          x.cm <- time.txt[take][other.take]
          dead.cm <- deadj[other.take]
          tot.cm <- totj[other.take]
          if(length(time.mono) < 2)
             do.abers <- F
       }
       if(do.abers) {
          if(link == "loglog")
             link <- "cloglog"
          lt.mono <- pool.adj(time.mono, dead.mono, tot.mono, phat = NULL, cm
              = cmk, cm.strategy = cm.strategy, cm.allcodes = cm.allcodes, 
             plimits = plimits, xtit = xaxtitle, plotit = fit.trend, link = 
             link, xfun = xfun, legend = leg.k, x.cm = x.cm, dead.cm = dead.cm,
             tot.cm = tot.cm, span = span.mono)
       }
       if(range.strategy == "individual")
          xrange <- switch(cm.strategy,
             adjust.later = ,
             abbott = range(times[take]))
       if(diff(range(xxlabels)) > 0)
          xlabels <- xxlabels
       else xlabels <- pretty(range(times[take]))
       if(line) {
          ltab <- ab
          b <- ltab[["slope"]][k]
          a <- ltab[["intercept"]][k]
       }
       else {
          a <- -999
          b <- -999
       }
       startx <- max(xmin, cutx[k])
       jk <- switch(n.strategy,
          id = j,
          mn = k)    #
       if(!do.abers) {
          simplot.t(xpos, rep(0, length(xpos)), totj, link, cm = cmk, 
             cm.strategy = cm.strategy, xtit = xaxtitle, ytit = ytitle, main = 
             " ", xfun = xfun, takelog = F, line = line, clip = c(startx, max(
             timesj)), xlimits = range(xpos), xlabels = xlabels, offset = 0, 
             plimits = plimits, mkh = mkh, xpos = xpos, title.line = title.line,
             id = NULL, lwd = lwd)
       }
       if(names(dev.cur()) == "postscript" & nchar(maint) > 0)
          mixed.mtext(texts = maint, side = 3, outer = T, cex = 1.25, line = 
             maint.line, adj = 0.5)
       else mtext(maint, 3, outer = T, cex = 1.3500000000000001, line = 
             maint.line)
    }
    if(cm.strategy == "abbott")
       mtext("Data is plotted following Abott's adjustment", 3, line = 
          maint.line - 1, outer = T, cex = 0.5)
    lt.leg <- paste(paste("lt", pc, ":", names(pc), sep = ""), collapse = "; ")
    par(cex = 0.40000000000000002)
    r.txt <- paste(lt.leg, "   ", unix("date +%d/%m/%y'  '%H:%M"))
    l.txt <- paste(unix("pwd"), as.character(as.name(match.call())), collapse
        = "")
    close.screen()
    if(datestamp) {
       mtext(r.txt, side = 1, adj = 1, outer = T, line = mtext.line)
       mtext(l.txt, side = 1, adj = 0, outer = T, line = mtext.line)
    }
}
hort.colours <-
structure(.Data = c(0, 1, 2, 3, 0.45833333333333331, 0.16666666666666666, 
    0.041666666666666664, 0.8125, 1, 1, 1, 1, 1, 1, 1, 1), .Dim = c(4, 4), 
    .Dimnames = list(character(0), c("nos", "all.kullas", "all.shades", "")))
incidence <-
function(data, y.cols = NULL, split.cols = NULL, rep.col = "Rep", threshold = 
    0.5, file = "", pad = "mid", append = F, help = F, between = F, dec = 3, 
    df.out = F)
{
# Made from summarize: might be some odd coding methods
# Requires  df.to.file() maybe: 
# 
# Last fixed 29/1/99
#
# Make sure parameters are all visible and right length    
    broadcast(dec)
    broadcast(threshold)
    if(len(threshold < len(y.cols))) threshold <- rep(threshold, len = len(
          y.cols))    #
# Make character vectors of y.cols and split.cols if necessary:
    if(is.numeric(y.cols))
       y.cols <- names(data)[y.cols]
    if(is.numeric(split.cols)) split.cols <- names(data)[split.cols]    #
# function to be used in tapply
    pc.over <- function(x, limit)
    {
       y <- x[!is.na(x)]
       no.over <- length(y[y > limit])
       over.pc <- (100 * no.over)/len(y)
    }
#
# Use dataframes instead of matrices:
    if(is.matrix(data))
       data <- unfactor(as.data.frame(data))
    else data <- unfactor(data)    # avoid pesky factors
    data <- df.sort(data, rev(split.cols))    #
# Create index and adjust for single split columns if necessary:
    indx.df <- data.frame(data[, split.cols])
    names(indx.df) <- split.cols    # Necessary for single split.cols
    attach(indx.df)
    indx <- NULL
    for(i in split.cols)
       indx <- paste(indx, get(i), sep = ":")
    detach("indx.df")
    out.df <- data.frame(indx.df[match(unique(indx), indx), split.cols])
    names(out.df) <- split.cols    # Necessary for single split.cols
    dimnames(out.df) <- list(paste(1:nrow(out.df)), names(out.df))
    for(j in y.cols)
       out.df[[ppaste(j, ".inc")]] <- s.tapply(data[, j], indx, pc.over, 
          threshold[find.pos(j, y.cols)])    #
    if(df.out) {
       names(out.df) <- c(split.cols, ppaste(y.cols, ".inc"))
       return(out.df)
    }
    else {
# Get rid of row number names: 
       out.mat <- as.matrix(out.df)
       dimnames(out.mat)[[1]] <- rep("", nrow(out.mat))
       out.df <- as.data.frame(out.mat)
       numeric.cols <- !sapply(out.df, function(x)
       any(is.na(as.numeric(x))))
       out.df[numeric.cols] <- lapply(out.df[numeric.cols], as.numeric)
       if(file == "")
          print(out.df)
       else {
          write(paste("\n"), file = file, append = append)
          append <- T    # hereafter appending will always be wanted
          df.to.file(out.df, file = file, append = append, pad = pad)
       }
    }
    invisible()
}
is.not.na <-
function(x)
{
# Returns a vector giving positions of non-null values of x
# For positions are that *are* NAs, use internal function which.na()
    seq(along = x)[!is.na(x)]
}
junk.df <-
structure(.Data = list(Fruit = structure(.Data = c(1, 4, 5, 3, 2, 1, 4, 5, 3, 2,
    1, 4, 5, 3, 2), .Label = c("apple", "apricot", "cherry", "pear", "plum"), 
    class = "factor"), Jan = c(4, 15, 10, 11, 14, 5, 8, 18, 11, 15, 18, 14, 11,
    5, 14), Feb = c(8, 13, 6, 5, 13, 12, 14, 9, 7, 13, 11, 9, 11, 14, 5), Mar
     = c(11, 15, 11, 13, 12, 13, 14, 15, 16, 15, 10, 16, 14, 10, 16), Apr = c(
    22, 15, 9, 13, 16, 21, 8, 18, 14, 22, 13, 18, 23, 10, 14), May = c(25, 11, 
    15, 18, 24, 15, 9, 11, 24, 17, 25, 23, 13, 20, 20)), row.names = c("1", "2",
    "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15"), 
    class = "data.frame")
last.dump <-
structure(.Data = list("No Frame Available", "FF(ps.colors, T)" = 
    "No Frame Available", "print(dmodes(fun.text, pos = i, ...))" = 
    "No Frame Available", "dmodes(fun.text, pos = i)" = "No Frame Available", 
    "apply(objs.mat, 1, function(x)" = "No Frame Available", 
    "lapply(split(newX, rep.int(1:newd[2], rep.int(newd[1], newd[2]))), function(X, "
     = "No Frame Available", "function(X, .NAMES, FUN, ...)" = 
    "No Frame Available", "FUN(X)" = "No Frame Available", "get.default(x)" = 
    "No Frame Available"), message = "Object \"\" not found")
last.warning <-
list("Condition has 3 elements: only the first used" = if(pse[i] == psS) {
    ine <- T
}
, "Condition has 3 elements: only the first used" = if(pse[i] == psS) {
    ine <- T
}
, "Condition has 3 elements: only the first used" = if(pse[i] == psS) {
    ine <- T
}
, "Condition has 3 elements: only the first used" = if(pse[i] == psS) {
    ine <- T
}
, "Condition has 3 elements: only the first used" = if(pse[i] == psS) {
    ine <- T
}
, "Condition has 3 elements: only the first used" = if(pse[i] == psS) {
    ine <- T
}
, "Condition has 3 elements: only the first used" = if(pse[i] == psS) {
    ine <- T
}
)
levels.for.genstat <-
function(x, no.quotes = T)
{
# Returns a string of the factor levels to use in genstat
# paste from between " marks
# change the opening and closing "   to ' if quotes are wanted
    paste(unique(x), collapse = ifelse(no.quotes, ",", "','"))
}
likelihood.ci <-
function(cm.n = c(0, 0), heatval, xbar, dead, tot, offset = 0, link = "cloglog",
    xfun.inv = exp, interval = T, pc = c(50, 99), dp = 1, save.resid = F, 
    cm.strategy = "adjust.later", full.robust = T)
{
# Uses robust glm
# heatval is the x-variable.
# xbar is a (usually centred) origin of measurement for heatval
    cm <- cm.n[1]
    numcm <- cm.n[2]
    pfrac <- pc/100
    if(cm.strategy == "adjust.later")
       pval <- cm + (1 - cm) * pfrac
    else pval <- pfrac
    n <- length(heatval)
    xvec <- heatval
    link.fun <- link.function(link)    #	inv.fun <- link.inverse(link)
    resid <- NULL
    resid.dev <- NULL
    if(cm.strategy == "adjust.later") {
       p <- dead/tot    #		ymat <- cbind(dead, tot - dead)
       reflect.logsurv <- 1
       if(link == "logsurv") {
          ymat <- cbind(tot - dead, dead)
          reflect.logsurv <- -1
       }
       if(link == "log" | link == "logsurv")
          fam <- quasi(link = log, variance = "mu(1-mu)")
       else fam <- robust(call("binomial", link))
       assign("pnx", data.frame(p.obs = p, x = heatval), frame = 1)
       assign("tot", tot, frame = 1)
       u.call <- call("glm", p.obs ~ x, data = pnx, family = fam, weight = tot)
       u <- eval(u.call)
       if(full.robust) {
          r1 <- residuals(u, type = "deviance")
          here.r <- abs(r1) != max(abs(r1))
          u2.call <- call("glm", p.obs ~ x, family = fam, data = pnx[here.r,  ],
             weight = tot[here.r])
          u2 <- eval(u2.call)
          assign("startr", predict(u2, newdata = pnx), frame = 1)
          u3.call <- call("glm", p.obs ~ x, family = fam, data = pnx, start = 
             startr, weight = tot)
          u <- eval(u3.call)
       }
       if(any(abs(u$weights) == Inf)) {
          u$weights[abs(u$weights) == Inf] <- 0    
    # Fudge to ensure calculations continue
       }
       uu <- summary.glm(u, correl = F)
       if(save.resid) {
          resid.dev <- residuals(u, type = "deviance") * reflect.logsurv
          resid <- residuals(u, type = "response") * reflect.logsurv
       }
       b0 <- uu$coef[1, 1] * reflect.logsurv
       b1 <- uu$coef[2, 1] * reflect.logsurv
       cm.est <- NULL    #	phat <- inv.fun(b0 + b1 * xvec)
       fit.p <- fitted(u)
       if(link == "logsurv")
          fit.p <- 1 - fit.p
       rob.info <- robust.deviance(fit.p, tot, dead)
       dev.robust <- rob.info[[1]]
       df.robust <- rob.info[[2]]
       dev0 <- uu$deviance
       disp0 <- uu$dispersion
       df0 <- uu$df[2]
    }
    else if(cm.strategy == "abbott") {
       uu <- abbott(cmobs = cm, numcm = numcm, dose = heatval, dead = dead, 
          total = tot, link = link, max.iter = 12, save.resid = save.resid)
       b0 <- uu$coef[1]
       b1 <- uu$coef[2]
       cm.est <- uu$cm
       dev0 <- uu$dev
       df0 <- length(heatval) - 2
       if(df0 > 0)
          disp0 <- dev0/df0
       else disp0 <- NA
       if(save.resid) {
          resid.dev <- uu$resid.dev
          resid <- uu$resid
       }
       dev.robust <- NULL
       df.robust <- NULL
    }
    else stop(paste("Unrecognized cm strategy:", cm.strategy))
    cat("Dev. =", format(round(dev0, 2)), "(df", df0, ")", "  [Disp =", format(
       round(disp0, 3)), "]", "  [Dev =", format(round(dev.robust, 2)), "(df", 
       df.robust, ")]", fill = T)
    if(!is.na(disp0)) {
       if(disp0 < 1)
          het <- 1
       else het <- disp0
    }
    else het <- NA
    if(!is.na(disp0)) {
       if(disp0 > 1)
          df.t <- df0
       else df.t <- Inf
    }
    else df.t <- NA
    v11 <- (uu$cov.un[1, 1]) * het
    v22 <- (uu$cov.un[2, 2]) * het
    v12 <- (uu$cov.un[1, 2]) * het
    ld <- xfun.inv((link.fun(pval) - b0)/b1 + xbar) - offset
    dp <- 2 - floor(log(ld[length(ld)])/log(10))
    if(is.na(dp))
       dp <- 1
    dp <- max(dp, 0)
    selog <- array(, length(pc))
    j <- 0
    if(!is.na(v22))
       for(percent in pval) {
          j <- j + 1
          if(b1/sqrt(v22) > 0.5) {
             ci <- fieller(percent, b0, b1, v11, v12, v22, df.t = df.t, link = 
                link)
             ld[j] <- xfun.inv(ci$xhat + xbar) - offset
             selog[j] <- sqrt(ci$var)
             cat(paste("LT", pc[j], ":",  , sep = ""), format(round(ld[j], dp)),
                "  ", fill = F)
             if(interval)
                if(ci$upper > ci$lower) {
                   cat("95% C.I. is", format(round(xfun.inv(ci$lower + xbar) - 
                      offset, dp)), " to", format(round(xfun.inv(ci$upper + 
                      xbar) - offset, dp)), fill = T)
                }
                else cat("  * CI could not be calculated (g =", paste(round(ci$
                      g, 5), ") *", sep = ""), fill = T)
          }
          else cat(paste("LT", pc[j], ":",  , sep = ""), format(round(ld[j], dp
                )), "   ", fill = T)
       }
    else {
       for(i in seq(along = pc))
          cat(paste("   LT", pc[i], ":", sep = ""), format(round(ld[i], dp)))
       cat("\n")
    }
    cept <- b0 - b1 * xbar
    se0 <- sqrt(v11)
    se1 <- sqrt(v22)
    cept <- b0 - b1 * xbar
    var.cept <- v11 + v22 * xbar^2 - 2 * xbar * v12
    rho.cept.b <- (v12 - xbar * v22)/sqrt(var.cept)/se1
    se <- c(sqrt(var.cept), se1)
    rho <- v12/(se0 * se1)
    cat("   Coeffs:", format(round(c(cept, b1), 4)), "[SE", format(round(se, 3)
       ), " r=", format(round(rho.cept.b, 5)), "]", "\n")
    list(coef = c(b0, b1), selog = selog, vcov = c(v11, v12, v22), df = df0, cm
        = cm.est, dev = dev0, dev.robust = dev.robust, df.robust = df.robust, 
       ld = ld, resid = resid, resid.dev = resid.dev)
}
link.function <-
function(link)
{
    link.options <- c("identity", "log", "logsurv", "logit", "sqrt", "inverse",
       "probit", "loglog", "cloglog", "help")
    if(link == "help")
       cat("\nOptions are:", paste(link.options, sep = "  "), "\n")
    link.int <- charmatch(link, link.options)
    if(is.na(link.int))
       stop("Invalid link type")
    else if(link.int == 0)
       stop("Ambiguous link type")
    g <- switch(link,
       identity = function(p)
       p,
       log = function(p)
       log(p),
       logsurv = function(p)
 - log(1 - p),
       logit = function(p)
       {
          p <- ifelse(p > 1, NA, ifelse(p < 0, NA, p))
          p1 <- ifelse(p > 1 - 9.9999999999999998e-17, 1 - 
             9.9999999999999998e-17, ifelse(p < 1.0000000000000001e-16, 
             1.0000000000000001e-16, p))
          log(p1/(1 - p1))
       }
       ,
       sqrt = function(p)
       sqrt(p),
       inverse = function(p)
       1/p,
       probit = qnorm,
       loglog = ,
       cloglog = function(p)
       {
          p <- ifelse(p > 1, NA, ifelse(p < 0, NA, p))
          p1 <- ifelse(p > 1 - 9.9999999999999998e-17, 1 - 
             9.9999999999999998e-17, ifelse(p < 1.0000000000000001e-16, 
             1.0000000000000001e-16, p))
          log(.Uminus(log(1 - p1)))
       }
       )
    g
}
link.inverse <-
function(link = "help")
{
    link.options <- c("identity", "log", "logsurv", "logit", "sqrt", "inverse",
       "probit", "loglog", "cloglog", "help")
    if(link == "help")
       cat("\nOptions are:", paste(link.options, sep = "  "), "\n")
    link.int <- charmatch(link, link.options)
    if(is.na(link.int))
       stop(paste("Invalid link type: \nOptions are:", paste(link.options, 
          collapse = " ")))
    else if(link.int == 0)
       stop("Ambiguous link type")
    f <- switch(link,
       identity = function(x)
       x,
       log = function(x)
       exp(x),
       logsurv = function(x)
       1 - exp( - x),
       logit = function(x)
       {
          z <- exp(ifelse(x > 80, 80, ifelse(x < -80, -80, x)))
          z/(z + 1)
       }
       ,
       sqrt = function(x)
       x^2,
       inverse = function(x)
       1/x,
       probit = pnorm,
       loglog = ,
       cloglog = function(x)
       {
          z <- exp(ifelse(x > 80, 80, ifelse(x < -80, -80, x)))
          1 - exp(.Uminus(z))
       }
       )
    f
}
list.mat <-
function(x)
{
# To convert a list of vectors into a matrix
#
# x must be a named list of "named vectors"
    rownames <- names(x)
    colnames <- names(x[[1]])
    mat <- matrix(nr = length(rownames), nc = length(colnames), dimnames = list(
       rownames, colnames))
    for(i in rownames)
       mat[i,  ] <- unlist(x[[i]])
    mat
}
list.to.data.frame <-
function(x)
{
# 1) Test list element lengths are the same
    lengths <- unlist(lapply(x, length))
    len <- mean(lengths)
    if(all(lengths == len)) {
       attr(x, "class") <- "data.frame"
       attr(x, "row.names") <- 1:len
    }
    else {
       stop("list elements are not of same length")
    }
    x
}
log.mean <-
function(vals, intv = 95)
{
# Shortened version of mean.lt()
# WARNING: lots of excess code; likely to be buggy
    interval <- intv/100
    if(!is.list(vals)) {
       lts <- round(as.numeric(vals), 5)
       lts <- lts[!is.na(lts)]
       reps <- length(lts)    
    # Have vector of grouped lts. Continue finding means, etc.
       av.log.lt <- mean(log(lts), na.rm = T)
       var.log.lt <- my.var(log(lts))    #
    }
    else {
       lts <- NULL
       spec <- NULL
       av.log.lt <- NULL
       var.log.lt <- NULL
       for(k in 1:length(vals)) {
          lts <- c(lts, vals[[k]])
          spec <- c(spec, rep(k, length(vals[[k]])))
       }
       av.log.lt <- tapply(log(lts), spec, mean, na.rm = T)
       var.log.lt <- tapply(log(lts), spec, my.var)    #
       reps <- tapply(lts, spec, function(x)
       length(x))
    }
    lt.3 <- matrix(lts, nc = 1)    #
# Replace any missing variances with zero	
    sem.log.lt <- sem(log(lts), na.rm = T)
    deg <- length(lts) - 1
    delta <- qt(1 - (1 - interval)/2, deg) * sqrt(var.log.lt/reps)
    log.up <- av.log.lt + delta
    log.low <- av.log.lt - delta
    lt.mean <- round(exp(av.log.lt), 1)
    upper <- round(exp(log.up), 1)
    lower <- round(exp(log.low), 1)
    sem <- round(sem.log.lt * lt.mean, 3)    #
# Make matrix of means, etc
    y <- cbind(reps, lt.mean, lower, upper, sem)
    x <- y[unique(spec),  ]    #
# Put individual LTs into matrix
    rn <- paste(spec)
    dimnames(lt.3) <- list(rn, NULL)
    urn <- unique(rn)
    cn <- max(table(rn))
    mm <- matrix(rep("---", length(urn) * cn), nc = cn, dimnames = list(urn, 
       paste("Rep", 1:cn, sep = "")))
    for(i in urn) {
# Not all rows have same number of reps
       kk <- lt.3[dimnames(lt.3)[[1]] == i]
       for(k in 1:length(kk))
          mm[i, k] <- kk[k]
    }
# Output to screen
    cat(c(paste("Separate values :", sep = ""), "\n\n"))
    tab.mat(mm)
    cat("\n\n")
    cat(c(paste("Means and ", intv, "% c.i.:", sep = ""), "\n\n"))
    tab.mat(x)
    cat("\n\n")
}
logit.bt <-
function(x)
{
    p <- exp(x)/(1 + exp(x))
}
lookup <-
function(x, y, z = NULL)
{
# Looks up a legend to find the corresponding elements of the input vector
#
# y has all possible values x could take;
# z has all corresponding unabbreviated values of interest
# This function returns those bits of z which correspond to the input values x
# 
# if z is NULL, y must be a matrix of two columns
    if(is.null(z) && dim(y)[2] != 2) stop("z must be specified OR y a matrix\n"
          )
    if(!is.null(dim(y))) {
       z <- y[, 2]
       y <- y[, 1]
    }
    names(z) <- y
    z[x]
}
make.df <-
function(text.file, ...)
{
# Making a dataframe from a text file and using tab separators
    read.table(text.file, T, as.is = T, sep = "\t", row.names = NULL, ...)
}
make.factors <-
function(df, fcols = 1, ordered = F, ...)
{
# To change specified columns into factors.  By default levels are reordered 
#    in alphabetical order.  Keeping that order makes it an ordered factor (ordered = T)
#    which does some strange things in glms and the like, but it's useful for ordering 
#    factors for trellis plotting.
#
#  Without named columns, will not work unless fcols are sequential (col nos. are used:
#    somehow that makes a difference)
#
# Vectors can also be used, in which case setting sorted to T is the same
#   as using factor()
#
    onecol <- is.null(dim(df))    #
    if(onecol) {
       vec <- unfactor(df)
       if(!ordered)
          df <- factor(vec, ...)
       else df <- ordered(vec, labels = unique(vec, ...))
    }
    else {
       if(is.character(fcols))
          fcols <- find.pos(fcols, names(df))
       for(i in fcols) {
          if(!ordered) {
             df[[i]] <- factor(df[[i]], ...)
          }
          else df[[i]] <- ordered(df[[i]], levels = unique(df[[i]]), ...)
       }
    }
    df
}
make.id <-
function(x)
{
# Creates one id value for each row.  Value increases by 1 for each
# element where the value of x is less than for the previous element.
    dx <- c(0, diff(x))
    u <- rep(0, length(x))
    u[dx < 0] <- 1
    cumsum(u) + 1
}
make.line.loess <-
function(xy, lab, label.pos = 0.90000000000000002, cex = par()$cex, lev.font = 
    1, lty = 1, lwd = par()$lwd, inclusion = "ALL", mark = T, mark.extra = "")
{
    overlap <- function(x, y, xl, yl)
    {
       over <- F
       i <- 1
       while(i <= length(xl)) {
          first.pair.match <- (1:length(xl[[i]]))[(xl[[i]] == x[1]) & yl[[i]] == 
             y[1]]
          if(is.na(diff(x)))
             browser()
          if((diff(x) == 0) & (diff(y) == 0)) {
             if(length(first.pair.match) > 0)
                over <- T
          }
          else {
             second.pair.match <- (1:length(xl[[i]]))[(xl[[i]] == x[2]) & yl[[i
                ]] == y[2]]
             names(first.pair.match) <- rep("f", length(first.pair.match))
             names(second.pair.match) <- rep("s", length(second.pair.match))
             pair.match <- sort(c(first.pair.match, second.pair.match))
             adj.pairs <- (1:(length(pair.match) - 1))[diff(pair.match) == 1]
             adj.pairs <- adj.pairs[!is.na(adj.pairs)]
             if(length(adj.pairs) > 0)
                if((names(pair.match)[adj.pairs[1]] == "f") & (names(pair.match
                   )[adj.pairs[1] + 1] == "s"))
                   over <- T
          }
          i <- i + 1
       }
       over
    }
    assign("overlap", overlap, 0)
    pos <- function(posn, x, y)
    {
       if(posn == 1)
          length(x)
       else {
          dx <- c(0, diff(x))
          dy <- c(0, diff(y))
          lengths <- sqrt(dx^2 + dy^2)
          cum.lengths <- cumsum(lengths)
          full.length <- cum.lengths[length(cum.lengths)]
          main.index <- ((1:length(cum.lengths))[cum.lengths > posn * 
             full.length])[1] - 1
          left.over <- posn * full.length - cum.lengths[main.index]
          main.index + left.over/lengths[main.index + 1]
       }
    }
    assign("pos", pos, 0)
    label.line <- function(label.pos, x, y, lab, cex, i, font)
    {
       if(label.pos >= 0) {
          j <- pos(label.pos, x, y)
          index <- trunc(j)
          if(!is.na(diff(x[index + 0:1])) & !is.na(diff(y[index + 0:1])))
             if(!overlap(x[index + 0:1], y[index + 0:1], x.keep, y.keep)) {
                j <- j - index
                tx <- x[index] + j * (x[index + 1] - x[index])
                ty <- y[index] + j * (y[index + 1] - y[index])
                text(tx, ty, lab, cex = cex, font = font)
                x.keep[[i - 1]] <- x
                y.keep[[i - 1]] <- y
                assign("x.keep", x.keep, 1)
                assign("y.keep", y.keep, 1)
             }
       }
    }
    plot.line <- function(x, y, lty, lwd, inclusion)
    {
       find.point <- function(inclusion, x, y, start)
       {
          p <- pos(inclusion, x, y)
          index <- trunc(p)
          p <- p - index
          tx <- x[index] + p * (x[index + 1] - x[index])
          ty <- y[index] + p * (y[index + 1] - y[index])
          list(tx = tx, ty = ty, index = index + start)
       }
       if(is.character(inclusion)) {
          lines(x, y, lty = lty, lwd = lwd)
          T
       }
       else if(is.null(inclusion))
          F
       else if(inclusion[1] == inclusion[2])
          F
       else {
          if(inclusion[1] > inclusion[2])
             inclusion <- c(inclusion[1], 1, 0, inclusion[2])
          x.save <- x
          y.save <- y
          for(i in 1:(length(inclusion) %/% 2)) {
             x <- x.save
             y <- y.save
             start <- find.point(inclusion[1 + (i - 1) * 2], x, y, T)
             finish <- find.point(inclusion[2 + (i - 1) * 2], x, y, F)
             x <- c(start$tx, x[start$index:finish$index], finish$tx)
             y <- c(start$ty, y[start$index:finish$index], finish$ty)
             lines(x, y, lty = lty, lwd = lwd)
          }
          T
       }
    }
## Main ##
    xy$x <- c(NA, xy$x, NA)
    na <- (1:length(xy$x))[is.na(xy$x)]
    xy$x <- xy$x[ - (na[diff(na) == 1])]
    xy$y <- c(NA, xy$y, NA)
    xy$y <- xy$y[ - (na[diff(na) == 1])]
    na <- (1:length(xy$x))[is.na(xy$x)]
    x.keep <- list()
    y.keep <- list()
    assign("x.keep", x.keep, 1)
    assign("y.keep", y.keep, 1)
    if(length(label.pos) < length(na) - 1)
       label.pos <- c(label.pos, rep(label.pos[1], length(na) - length(
          label.pos)))
    cat("Lev ", lab, mark.extra, " Lines ", max(length(na) - 1, 0), "\n", sep
        = "")
    if(length(na) > 0)
       for(i in 2:length(na)) {
          x <- xy$x[(na[i - 1] + 1):(na[i] - 1)]
          y <- xy$y[(na[i - 1] + 1):(na[i] - 1)]
          old.x <- x
          old.y <- y
          x <- x[!is.na(old.x) & !is.na(old.y)]
          y <- y[!is.na(old.x) & !is.na(old.y)]
          if(length(x) > 0) {
             if(plot.line(x, y, lty, lwd, inclusion[[i - 1]]))
                label.line(label.pos[i - 1], x, y, paste(lab, ifelse(mark, 
                   paste(mark.extra, "-", i - 1, sep = ""), ""), sep = ""), cex,
                   i, font = lev.font)
          }
       }
}
mean.effects.table <-
function(object, INDICES, table.name, sed.print, ur, X1, f1, coeffs, cov = NULL,
    digits = 4, se.fit = T)
{
# function to calculate and print one mean effects table
# (C) R.D. Ball, HortResearch Institute NZ 2/10/93
# called by mean.effects.tables
# object : an aov or lm object
# table.name : character, a name for the table
# INDICES : an index or list of indices for the table
# sed.print = 1,2,3 for av s.e.d., a summary with min,av,max s.e.d.
# or the full matrix of s.e.d.'s respectively.
    calc.seds <- function(V)
    {
### return the matrix of standard errors of differences of x with	
### variance covariance matrix V 	
### diagonal entries are standard errors of entries of x
       if(!(is.matrix(V) && (n <- dim(V)[1]) == dim(V)[2])) stop(
             "Variance covariance must be a square matrix")
       seds <- matrix(rep(0, n^2), nc = n, nr = n)
       D <- diag(V)
       seds <- sqrt(D + t(D + t(-2 * V)))
       cat("after calculating seds, (original formula)", date(), "\n")    
    ## Richard Heiberger's suggestion
       seds <- sqrt(outer(D, D, "+") - 2 * V)
       cat("after calculating seds, (Heiberger's formula)", date(), "\n")
       diag(seds) <- sqrt(diag(V))
       seds
    }
    if(missing(INDICES))
       stop("no table requested")
    if(!is.list(INDICES))
       INDICES <- list(INDICES)    ## object specific
    if(missing(coeffs)) coeffs <- coefficients(object)    
    # for class "varcomp" although it inherits from "lm"
# it doesn't have enough to use summary.lm()	
#	browser()
    if(missing(X1)) {
       if(match("varcomp", class(object), nomatch = 0)) {
## RDB 9/7/93 : assign.fixed only matches terms with coefs
          X <- model.matrix(object)
          X <- X[, match(names(coeffs), dimnames(X)[[2]])]    
    ## wrong; can pick up random components
## X <- model.matrix(object)[, unlist(object$assign.fixed)]
       }
       else {
          X <- model.matrix(object)[, unlist(object$assign)]
       }
       if(missing(ur)) {
          urows <- unique.rows(X)
          ur <- unique(urows)    ## RDB 17/7 ,use C new function
#			ur <- unique.cols(t(X))
       }
       X1 <- X[ur,  ]
    }
    if(any(dimnames(X1)[[2]] != names(coeffs)))
       stop(
          "names of coefficients don't match names fixed columns of model matrix"
          )
    check.calc <- F
    if(missing(sed.print)) {
       sed.print <- sed.print.default <- 2
       if(!is.null(print.attr <- attr(object, "sed.print")))
          sed.print <- match(print.attr, c("av", "summary", "all"), nomatch = 0
             )
    }
#  if (missing(dnames))
#    dnames_dimnames(X1)[[1]]
    if(missing(f1)) f1 <- X1 %*% coeffs    
    #	if (se.fit & missing(cov) & is.null(object$R)){
#	  formul_object$call$formula
## the usual potential problem here if called from within a function
#	  y_eval(object$call$formula[[2]],sys.parent(1))
#	  lmobj_aov(y ~ X)
#          object$R <- lmobj$R
#	  object <- lmobj
#	}
#	browser()
    if(missing(cov) & se.fit) {
       if(match("varcomp", class(object), nomatch = 0)) {
# class "varcomp"
#		  browser()
          cov <- object$cov.fixed    
    # a current inconsistency when method=="reml"
          reml.cov.inconsistency.fixed <- F
          if(!reml.cov.inconsistency.fixed) {
             cov.dnames <- dimnames(cov)
             if(match("reml", object$method, nomatch = 0)) {
#		browser()
                cov.row.ind <- match(names(coeffs), cov.dnames[[1]])
                cov.col.ind <- match(names(coeffs), cov.dnames[[2]])
                if(any(is.na(cov.row.ind) | is.na(cov.col.ind)))
                   stop(
                      "incompatible coefficients and fixed effects covariance matrix"
                      )
                cov <- cov[cov.row.ind, cov.col.ind]
             }
             else {
# varcomp, method!="reml"
                cov <- cov * object$variances["Residuals"]
                if(any(names(coeffs) != cov.dnames[[1]] | names(coeffs) != 
                   cov.dnames[[2]])) {
# should never get here
                   stop(
                      "names of coefficients not same as names for covariance")
                }
             }
          }
       }
       else {
# class "aov" or "glm"
          ms <- summary(object)$"Mean Sq"
          rms <- ms[length(ms)]
          if(!is.null(ms) & !is.null(rms))
             cov <- summary.lm(object)$cov.unscaled * rms
          if(is.null(cov) && !is.null(sigma <- summary.lm(object)$sigma))
             cov <- summary.lm(object)$cov.unscaled * sigma^2
          if(is.null(cov) && !is.null(sigma1 <- summary(object)$sigma)) {
             sigma <- sigma1
             cov <- summary.lm(object)$cov.unscaled * sigma^2
          }
          if(is.null(cov))
             warning("insufficient information to calculate covariance matrix")
       }
    }
## table specific
    IND <- lapply(INDICES, function(x, sel)
    x[sel], sel = ur)    #	browser()
    if(missing(table.name)) {
       ind.char <- as.character(substitute(INDICES))
       if(length(ind.char) > 1 && ind.char[1] == "list")
          ind.char <- ind.char[-1]
       table.name <- paste(ind.char, collapse = " by ")
    }
    cat("\nTable of", table.name, "\n")
    cat("*** mean effects ***\n")    #  cat(date(),"\n")
# this is only fair if all factor combinations are represented
    mean.effects <- tapply(f1, IND, mean)    
    #  cat("after calc. mean effects using fitted values",date(),"\n")
#  browser()
    n1 <- length(f1)
    ind <- tapply(rep(1, n1), IND)
    reps <- table(ind)
    C1 <- matrix(0, nr = length(ind), nc = max(ind))    
    # Was  C1 <- matrix(0, nr = length(ind), nc = ind(length(ind)))
    C1[1:length(ind) + length(ind) * (ind - 1)] <- (1/reps)[ind]
    X2 <- t(C1) %*% X1
    if(check.calc) {
       mean.effects.too <- X2 %*% coeffs
       X2.too <- apply(X1, 2, function(x, s)
       tapply(x, s, mean), IND)
       cat("any(abs(X2.too-X2) > 1e-4)" = any(abs(X2.too - X2) > 0.0001), "\n")
       cat("range(c(mean.effects)-mean.effects.too) = ", range(c(mean.effects) -
          mean.effects.too), "\n")
    }
    dummy.tbl <- tapply(X1[, 1], IND, mean)    
    #  cat("after calc. mean effects using matrix mult",date(),"\n")
    reps <- tapply(object$fitted, INDICES, length)
    if(is.array(dummy.tbl)) {
       mean.effects <- array(mean.effects, dim = dim(dummy.tbl), dimnames = 
          dimnames(dummy.tbl))
       dimnames(reps)[[1]] <- rep("rep", dim(reps)[1])
       mean.effects.tbl <- rbind.arrays(mean.effects, reps, interleave = T)
    }
    else {
       mean.effects.tbl <- rbind(t(mean.effects), reps)
       dimnames(mean.effects.tbl)[[1]] <- c("", "rep")
    }
    if(check.calc) {
       cat("before calc. mean effects using fitted values", date(), "\n")
       mean.effects.too <- tapply(f1, IND, mean)
       cat("before calc. mean effects using fitted values", date(), "\n")
       if(any(abs(mean.effects - mean.effects.too) > 0.0001))
          stop("error in mean effects calculation")
    }
    print(mean.effects.tbl, digits = digits)
    seds <- NULL
    if(se.fit & !is.null(cov)) {
#    cat("before calc.seds",date(),"\n")
       seds <- calc.seds(X2 %*% cov %*% t(X2))    
    #    cat("after calc.seds",date(),"\n")
       lower <- col(seds) < row(seds)
       L <- seds[lower]
       av <- sqrt(mean(L[!is.na(L)]^2))
       rg <- range(L[!is.na(L)])
       if(diff(rg) == 0 && sed.print > 2)
          sed.print <- 2
       cat("*** seds ***\n")
       switch(sed.print,
          print(c(av = av)),
          print(c(min = rg[1], av = av, max = rg[2])),
          {
             seds.char <- as.character(format(round(seds, digits)))
             dim(seds.char) <- dim(seds)    #	     browser()
             seds.char[!lower] <- ""
             seds.char[row(seds) == col(seds)] <- "*"
             print(seds.char, quote = F)
          }
          )
    }
    invisible(list(means = mean.effects, seds = seds))
}
mean.lc <-
function(start.list = ab.soluble, lc = 50, choose = 1, intv = 95)
{
# Requires LC data in an ab. type list with sublist names such as "total"
# referring to LCs at those locations
# Compares effect of pooling and normal cms on 
# LC50s calculated by mono fit: LC99s calculated by line fit
# Has to group species to take mean, and then restore to the original
#  order of species (otherwise, it's very simple)
    type <- switch(as.character(substitute(start.list)),
       ab.soluble = "toxin CryIB",
       ab.crystal = "toxin 517",
       ab.jocosa = "Jocosa vs purified Bt517")
    interval <- intv/100
    if(is.character(choose)) {
       choose.i <- (1:length(names(start.list)))[names(start.list) == 
          as.character(choose)]
    }
    else (choose.i <- choose)
    ab <- start.list[[choose.i]]
    spec <- substring(ab$legend, 1, 3)
    uniq.spec <- unique(spec)
    sortspec <- sort(spec)
    temp.vector <- ab$temp
    temp <- as.numeric(temp.vector)
    if(lc == 50)
       lc.vector <- ab$lt.monotone[, "50"]
    else if(lc == 99)
       lc.vector <- ab$lt[, "99"]
    else stop(
          "\n Designed only for LC50s and LC99s: specifiy which one; default is 50"
          )
    lcs <- round(as.numeric(lc.vector), 3)
    lc.1 <- matrix(lcs, ncol = 1, dimnames = list(spec, NULL))
    lc.2 <- NULL    #
# Sort to arrange species together
    for(i in unique(spec)) {
       lc.2 <- c(lc.2, lc.1[dimnames(lc.1)[[1]] == i,  ])
    }
# Change vector into single column matrix
    lc.3 <- matrix(lc.2, nc = 1, dimnames = list(names(lc.2), NULL))    #
# Have vector of grouped lcs. Continue finding means, etc.
    av.log.lc <- tapply(log(lcs), spec, mean, na.rm = T)
    var.log.lc <- tapply(log(lcs), spec, my.var)
    sem.log.lc <- tapply(log(lcs), spec, sem, na.rm = T)
    reps <- table(spec[!is.na(lcs)])
    deg.pool <- sum(reps - 1)
    ind.var.free <- var.log.lc * (reps - 1)
    pool.var.free <- sum(ind.var.free)/deg.pool
    delta <- qt(1 - (1 - interval)/2, deg.pool) * sqrt(pool.var.free/reps)
    log.up <- av.log.lc + delta
    log.low <- av.log.lc - delta
    lc.mean <- round(exp(av.log.lc), 2)
    upper <- round(exp(log.up), 2)
    lower <- round(exp(log.low), 2)
    sem <- round(sem.log.lc * lc.mean, 3)
    y <- cbind(reps, lc.mean, lower, upper, sem)
    x <- y[uniq.spec,  ]
    lc.list <- list(lc.3, x)
    names(lc.list) <- c(paste("Separate LC50s using ", type, sep = ""), paste(
       "Mean LC 50s and ", intv, "% c.i.", sep = ""))
    lc.list
}
mean.lt <-
function(start.list = ab.soluble, choose = 1, lt = 99, intv = 95, new.order = F,
    leg.beg = NULL, leg.end = 4, insect = "interesting critters", fit = NULL, 
    two.tables = F)
{
# Requires LT data in an ab. type list with sublist names such as "total"
# referring to LTs at those locations
#
# LT50s calculated by mono fit: LT99s calculated by line fit
# Has to group species to take mean, and then restore to the original
#  order of species (otherwise, it's very simple)
# The name "species" really refers to location and life stage in 
#   some cases: it is what appears on the individual mortality plots
#
# leg.end will usually be used to remove "Rep_" from hames. If there are more than 
#  9 reps in the legend name, it won't work.
#
# leg.beg is the number of characters to omit from the legend text in determining what
#    groups similar trials 
# leg.beg by default is the postion of the first blank in the legend name: That is 
#   to allow the practice of having trial numbers in that legend: if there's no space
#   in the legend, it won't work.
    ablist <- as.character(substitute(start.list))
    leng.name <- nchar(ablist)
    interval <- intv/100
    if(is.character(choose)) {
       choose.i <- (1:length(names(start.list)))[names(start.list) == 
          as.character(choose)]
    }
    else (choose.i <- choose)
    ab <- start.list[[choose.i]]
    legs <- as.character(ab$legend)    
    # Seems to be necessary for correct class
    if(is.null(leg.beg)) {
# Find the first space in the legend names:
       leg.beg <- NULL
       for(k in 1:length(legs)) {
          leg.vec <- paste(substring(legs[k], 1:nchar(legs[k]), 1:nchar(legs[k]
             )), sep = "")
          leg.beg[k] <- match(" ", leg.vec)
       }
    }
    spec <- substring(legs, leg.beg + 1, nchar(legs) - leg.end)
    uniq.spec <- unique(spec)
    sortspec <- sort(spec)
    if(is.null(fit))
       fit <- ifelse(lt == 50, "monotone", "line")
    if(fit == "line")
       lt.vector <- ab$lt[, paste(lt)]
    else lt.vector <- ab$lt.monotone[, paste(lt)]
    type <- paste(insect, "  [", choose, "] (", fit, " fit)", sep = "")
    lt.vector[lt.vector < 0] <- NA
    lts <- round(as.numeric(lt.vector), 5)
    lt.1 <- matrix(round(lts, 1), ncol = 1, dimnames = list(spec, NULL))
    lt.2 <- NULL    #
# Sort to arrange species together
    for(i in uniq.spec) {
       lt.2 <- c(lt.2, lt.1[dimnames(lt.1)[[1]] == i,  ])
    }
# Change vector into single column matrix
    lt.3 <- matrix(lt.2, nc = 1, dimnames = list(names(lt.2), NULL))    #
# Have vector of grouped lts. Continue finding means, etc.
    av.log.lt <- tapply(log(lts), spec, mean, na.rm = T)
    var.log.lt.i <- tapply(log(lts), spec, my.var)    #
# Replace any missing variances with zero	
    var.log.lt <- ifelse(is.na(var.log.lt.i), 0, var.log.lt.i)
    sem.log.lt <- tapply(log(lts), spec, sem, na.rm = T)
    reps <- tapply(lts, spec, function(x)
    length(x[!is.na(x)]))
    deg.pool <- sum(reps[reps > 0] - 1)
    ind.var.free <- var.log.lt * (reps - 1)
    pool.var.free <- sum(ind.var.free)/deg.pool
    delta <- qt(1 - (1 - interval)/2, deg.pool) * sqrt(pool.var.free/reps)
    log.up <- av.log.lt + delta
    log.low <- av.log.lt - delta
    lt.mean <- round(exp(av.log.lt), 1)
    upper <- round(exp(log.up), 1)
    lower <- round(exp(log.low), 1)
    sem <- round(sem.log.lt * lt.mean, 3)    #
# Make matrix of means, etc
    y <- cbind(reps, lt.mean, lower, upper, sem)
    x <- y[uniq.spec,  ]    #
# Put individual LTs into matrix
    rn <- dimnames(lt.3)[[1]]
    urn <- unique(rn)
    cn <- max(table(rn))
    mm <- matrix(rep("---", length(urn) * cn), nc = cn, dimnames = list(urn, 
       paste("Rep", 1:cn, sep = "")))
    for(i in urn) {
# Not all rows have same number of reps
       kk <- lt.2[names(lt.2) == i]
       for(k in 1:length(kk))
          mm[i, k] <- kk[k]
    }
# If original order of plots is not wanted, sort into new order
    if(new.order) {
       mm <- mm[order(dimnames(mm)[[1]]),  ]
       x <- x[order(dimnames(x)[[1]]),  ]
    }
# Output to screen
    if(two.tables) {
       cat(c(paste("Separate LT", lt, "s for ", type, ":", sep = ""), "\n\n"))
       tab.mat(mm)
       cat("\n\n")
       cat(c(paste("Mean LT", lt, "s and ", intv, "% c.i.:", sep = ""), "\n\n")
          )
       tab.mat(x)
       cat("\n\n")
    }
    else {
       one.table <- cbind(mm, x)
       cat(c(paste("Separate LT", lt, "s with mean and ", intv, "% c.i. for ", 
          type, ":", sep = ""), "\n\n"))
       tab.mat(one.table)
    }
}
mean.lt.short <-
function(lt.vector, lt = 99, intv = 95)
{
# Shortened version of mean.lt()
    interval <- intv/100
    lts <- round(as.numeric(lt.vector), 5)
    lts <- lts[!is.na(lts)]
    reps <- length(lts)    # Change vector into single column matrix
    lt.3 <- matrix(lts, nc = 1)    #
# Have vector of grouped lts. Continue finding means, etc.
    av.log.lt <- mean(log(lts), na.rm = T)
    var.log.lt <- my.var(log(lts))    #
# Replace any missing variances with zero	
    sem.log.lt <- sem(log(lts), na.rm = T)
    deg <- length(lts) - 1
    delta <- qt(1 - (1 - interval)/2, deg) * sqrt(var.log.lt/reps)
    log.up <- av.log.lt + delta
    log.low <- av.log.lt - delta
    lt.mean <- round(exp(av.log.lt), 1)
    upper <- round(exp(log.up), 1)
    lower <- round(exp(log.low), 1)
    sem <- round(sem.log.lt * lt.mean, 3)    #
# Make vector of means, etc
    y <- matrix(c(reps, lt.mean, lower, upper, sem), nr = 1)
    dimnames(y) <- list(NULL, c("reps", "lt.mean", "lower", "upper", " sem"))
        # Put individual LTs into vector
    mm <- matrix(round(lts, 1), nr = 1)
    dimnames(mm) <- list(NULL, paste("Rep", 1:length(mm), sep = ""))    
    # Output to screen
    cat(c(paste("Separate LT", lt, "s ", sep = ""), "\n\n"))
    tab.mat(mm)
    cat("\n\n")
    cat(c(paste("Mean LT", lt, "s and ", intv, "% c.i.:", sep = ""), "\n\n"))
        #if(dim(y)[1]==1)
#x_matrix(x,nc=5,dimnames=dimnames(y))
    tab.mat(y)
    cat("\n\n")
}
modes <-
function(x = "", pos = 1, max = NULL, sort.by = "Object")
{
# Returns a Data frame showing modes of objects in the stated directory.
# Can be sorted by Mode, Length, or Date in addition to default Object
# A variation on this one is modes(). Made for lazy typists to sort by object name 
# max is the maximum number of objects returned; useful if ls() is long and 
#  you're only interested in the first few
    ls.o <- ls(x, pos = pos)
    if(!is.null(max) & max > length(ls.o))
       print(paste("Only", length(ls.o), "match", x, "in", search()[pos], 
          "directory"))
    if(is.null(max) | (max > length(ls.o)))
       max <- length(ls.o)
    if(sort.by == "Date")
       dir <- unix(paste("ls -lat ", search()[pos], sep = ""))
    else dir <- unix(paste("ls -la ", search()[pos], sep = ""))    #
    dir.names <- substring(dir, 55, nchar(dir))    #
# Will contain .Audit and .. files that aren't in the ls() list
    want <- match(dir.names, ls.o)
    wants <- want[!is.na(want)][1:max]
    options(warn = -1)
    on.exit(options(warn = 0))
    out <- list()
    dir.objs <- ls.o[wants]
    out$Object <- dir.objs
    objs.mat <- cbind(dir.objs)
    out$Mode <- apply(objs.mat, 1, function(x)
    mode(get(x)))    #
# Dimension information of dataframes and matrices
    dimensions <- apply(objs.mat, 1, function(x)
    dim(get(x)))
    y <- dimensions
    if(!is.null(y)) {
       y[unlist(lapply(y, is.null))] <- list(c(NA, NA))
       z <- t(matrix(unlist(y), byrow = F, nc = len(y)))
       z[is.na(z)] <- "-"
       out$Rows <- z[, 1]
       out$Cols <- z[, 2]
    }
    else out$Cols <- out$Rows <- rep("-", len(out$Object))
    out$Len <- apply(objs.mat, 1, function(x)
    length(get(x)))    #
# Rearrange date information
    date.info <- substring(dir, 42, 53)[find.pos(dir.objs, dir.names)]
    year <- substring(date.info, 8, 12)
    day <- substring(date.info, 5, 6)
    month <- substring(date.info, 1, 3)
    out$Date <- paste(day, month, year)
    long.name <- max(nchar(out$Object))
    ob.spaces <- long.name/2 - 3
    out$Mode[out$Mode == "list" & out$Rows != "-"] <- "dataframe"
    out.df <- unfactor(as.data.frame(out), c("Object", "Mode"))
    if(sort.by != "Date") out.df <- out.df[order(out.df[, sort.by]),  ]    #
# If date order is wanted, use the Unix ls, sorted by date, otherwise sort 
#   in S
    names(out.df) <- c(paste("Object", paste(rep(" ", ob.spaces), collapse = ""
       )), "Mode  ", "Rows", "Cols", "Len", "Date    ")
    out.df
}
month.length <-
c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
motif.l <-
function()
{
# A normal motif function to put the window in bottom right corner
    motif("-geometry -1-1")
}
motif.n <-
function()
{
# A normal motif function to put the window in bottom right corner
    motif("-geometry -1-1")
}
motif.p <-
function()
{
# To create a motif window that does portrait plotting
    ps.options(horizontal = F)
    motif("-geometry 568x817-1-1")
    cat("ps.options()$horizontal is now F\n")
}
motif.t <-
function()
{
# Starts a trellis motif graphics window placed in lower right corner
    trellis.device("motif", options = "-geometry -1-1")
}
motif.tp <-
function()
trellis.device("motif", options = "-geometry 568x750-1-1")
multi.nom <-
function(size = 20)
{
# A pretend multinomial simulator ....
    pick <- sample(1:400, size)
    lines <- 1:40
    line <- ceiling(pick/10)
    any(is.na(match(lines, line)))
}
my.var <-
function(x)
{
    here <- !is.na(x)
    if(length(here[here]) == 0)
       yy <- NA
    else yy <- var(x[here])
    yy
}
new.ps.colours <-
function(intervals = 48, shades = 5, black = F)
{
#Makes a new ps.colours object
    nos <- 1:(intervals * shades)
    u.kullas <- seq(0, 1, length = intervals + 1)[-1]
    all.kullas <- rep(u.kullas, shades)
    u.shades <- seq(1, 0, l = shades + 1)[ - shades - 1]
    all.shades <- rep(u.shades, rep(intervals, shades))
    ps.colors <- cbind(nos, all.kullas, all.shades, rep(1, length(nos)))
    if(black) {
       ps.colors[, "nos"] <- ps.colors[, "nos"] + 1
       ps.colors <- rbind(c(1, 0, 0, 0), ps.colors)
    }
    ps.colors
}
occurrence <-
function(x, char = " ", positions = 1)
{
# Finds positions of specified occurrences of a  character (char) in a 
#  character string (x), or vector thereof
#
# Default is to find the first occurrence.  A vector of occurrences can be given
    if(!is.character(x)) stop(
          "occurrence() applicable only for character strings")
    how.many <- len(positions)
    z <- as.list(x)
    broadcast(char)
    broadcast(how.many)
    find.gaps <- function(a, b)
    {
       size <- 1:nchar(a)
       (size)[substring(a, 1:nchar(a), 1:nchar(a)) == b]
    }
    broadcast(find.gaps)
    y <- lapply(z, function(w)
    find.gaps(w, char))
    names(y) <- paste(1:len(y))
    if(any(diff(table(sapply(y, len)))) > 0) {
# Fix up odd ones
       browser()
       long.y <- names(y[sapply(y, len) > how.many])
       zero.y <- names(y[sapply(y, len) == 0])
       y[long.y] <- lapply(y[long.y], function(x)
       x[1:how.many])
       y[zero.y] <- rep(NA, len(how.many))
    }
    t(matrix(unlist(y), byrow = F, nc = len(y)))[, positions]
}
p.sunflowers <-
function(x, y, number, size = 0.125, add = FALSE, rotate = F, pch = 16, ...)
{
## Purpose: Produce a 'sunflower'-Plot
## -------------------------------------------------------------------------
## Arguments: x,y: coordinates;
##    number[i] = number of times for (x[i],y[i])  [may be 0]
##    size: in inches		add : Should add to a previous plot ?
##    rotate: randomly rotate flowers?	further args: as for plot(..)
## -------------------------------------------------------------------------
## Authors: Andreas Ruckstuhl, Werner Stahel, Martin Maechler, Tim Hesterberg
## Date   : Aug 89 / Jan 93,   March 92,      Jan, Dec 93,        Jan 93
## Examples: p.sunflowers(x=sort(2*round(rnorm(100))), y=round(rnorm(100),0))
## ~~~~~~~~  p.sunflowers(rnorm(100),rnorm(100),number=rpois(n=100,lambda=2), 
##                        rotate=T, main="Sunflower plot")
    n <- length(x)
    if(length(y) != n)
       stop("x & y must have same length !")
    if(missing(number)) {
       orderxy <- order(x, y)
       x <- x[orderxy]
       y <- y[orderxy]
       first <- c(T, (x[-1] != x[ - n]) | (y[-1] != y[ - n]))
       x <- x[first]
       y <- y[first]
       number <- diff(c((1:n)[first], n + 1))
    }
    else {
       if(length(number) != n)
          stop("number must have same length as x & y\n!")
       x <- x[number > 0]
       y <- y[number > 0]
       number <- number[number > 0]
    }
    n <- length(x)
    if(!add) {
       axislabels <- match(c("xlab", "ylab"), names(list(...)))
       if(!is.na(axislabels[1]))
          xlab <- list(...)[[axislabels[1]]]
       else xlab <- deparse(substitute(x))
       if(!is.na(axislabels[2]))
          ylab <- list(...)[[axislabels[2]]]
       else ylab <- deparse(substitute(y))
       plot(x, y, xlab = xlab, ylab = ylab, type = "n", ...)
    }
    nequ1 <- number == 1
    if(any(nequ1))
       points(x[nequ1], y[nequ1], pch = pch, csi = size * 1.25)
    if(any(!nequ1))
       points(x[!nequ1], y[!nequ1], pch = pch, csi = size * 0.80000000000000004
          )
    i.multi <- (1:n)[number > 1]
    if(length(i.multi)) {
       ppin <- par()$pin
       pusr <- par()$usr
       xr <- (size * abs(pusr[2] - pusr[1]))/ppin[1]
       yr <- (size * abs(pusr[4] - pusr[3]))/ppin[2]
       i.rep <- rep(i.multi, number[number > 1])
       z <- NULL
       for(i in i.multi)
          z <- c(z, 1:number[i] + if(rotate) runif(1) else 0)
       deg <- (2 * pi * z)/number[i.rep]
       segments(x[i.rep], y[i.rep], x[i.rep] + xr * sin(deg), y[i.rep] + yr * 
          cos(deg))
    }
}
panel.superpose <-
function(x, y, subscripts, groups, type = "p", lwd = superpose.line$lwd, lty = 
    superpose.line$lty, pch = superpose.symbol$pch, cex = superpose.symbol$cex,
    font = superpose.symbol$font, col = NULL, solidpoints = T, ...)
{
    superpose.symbol <- trellis.par.get("superpose.symbol")
    superpose.line <- trellis.par.get("superpose.line")
    groups <- as.numeric(as.factor(groups))[subscripts]
    max.groups <- max(groups)
    type <- rep(type, length = max.groups)
    lty <- rep(lty, length = max.groups)
    lwd <- rep(lwd, length = max.groups)
    pch <- rep(pch, length = max.groups)
    cex <- rep(cex, length = max.groups)
    font <- rep(font, length = max.groups)
    if(is.null(col)) {
       sl <- rep(superpose.line$col, length = max.groups)
       ss <- rep(superpose.symbol$col, length = max.groups)
       col <- numeric(max.groups)
       for(i in 1:max.groups)
          col[i] <- if(type[i] == "l") sl[i] else ss[i]
    }
    else col <- rep(col, length = max.groups)
    N <- seq(along = groups)
    for(i in sort(unique(groups))) {
       which <- N[groups == i]    #		j <- which[order(x[which])]	# sort in x
       j <- which    # no sorting
       if(type[i] == "l") {
          lines(x[j], y[j], col = col[i], lwd = lwd[i], lty = lty[i], pch = " ",
             type = type[i], ...)
       }
       else {
          points(x[j], y[j], col = col[i], pch = pch[i], cex = cex[i], font = 
             font[i], type = type[i], lwd = lwd[i], lty = lty[i], ...)
          if(solidpoints && lty[i] != 1) {
             points(x[j], y[j], col = col[i], pch = pch[i], cex = cex[i], font
                 = font[i], type = "p", lwd = lwd[i], lty = 1, ...)
          }
       }
    }
}
plot.lt <-
function(lt = 99, datafun = get.leaf, choose = "lbam", fun = function(x)
x, poly = T, poly.limits = list(NULL), poly.keep.x = list(NULL), 
    poly.plot.limits = list(NULL), deg = 2, splin = F, wide.legend = 1, 
    high.legend = 1, expand.y = 0, print.statistics = T, x.limits = NULL, 
    y.limits = NULL, predict.x = NULL, confidence = 0.94999999999999996, 
    compare = NULL, fit.robust = F, plot.ci = F, plotit = T, plot.means = T, 
    plot.points = F, plot.single.sem = F, plot.groups.sem = T, legend.sem = T, 
    legend.linespace = 1.25, errors = "aov", include = NULL, parallel = NULL, 
    mkh = 0.080000000000000002, datestamp = T, prefix = "", prefix.y = "", 
    legend.header = "", legend.note = 
    "Limits shown are one SE\neither side of the mean", bars.pretext = "2 SE", 
    na.means = T, wts = NULL, style = list(lwd = 1, plotch = c(0, 1, 2, 5, 3, 4,
    16, 18, 6:15), cex.labels = 1, cex.title = 1.1499999999999999, mai.xtra = c(
    0.25, 0.5, 0.25, 0.5)), mtext.line = -1)
{
# Means, for each temperature in each list item, are calculated and plotted
# An overall SD is calculated for each set of list items, 
# as identified in groups.
# Set na.means to F to omit plotting of means when data for a mean relies
# partly on NAs
# Examples
# plot.lt(lt=50,datafun=get.air.CA.lt,poly=F, poly.limits=list(c(32.5,40)), 
# splin=T,wide.legend=0.67)
# plot.lt(lt=50,datafun=get.co2.o2.lt,poly=c(T,F),deg=1, splin=F,wide.legend=0.67)
# plot.lt(lt=99,datafun=get.co2.o2.lt,poly=c(T,F),deg=2, splin=F,wide.legend=0.67)
# plot.lt(lt=50,datafun=get.pretreat.lt,poly=T,deg=2, splin=F,wide.legend=0.67)
#
# aov.errors = T causes the within x mean square to be used for SEs etc.
#
# lt= : gives lt % to be printed on the y-axis label
#
# datafun: This function collects up the data, labelling information etc., 
# and delivers it in a standard form to plot.lt.
#
# fun: Transformation function for the y-axis.  Usually identity or log.
#
# poly: T if a line or polynomial is required.
#
# poly.limits: used in connection with splin=T when a specific polynomial
# (usually a quadratic) is required over the part of the range specified 
# by poly.limits, with a spline for the remainder.
# 
# deg: degree for polynomial(s)
#
# Note: Parameters poly, poly.limits and deg are expanded, if necessary, 
# into a vector or (for poly.limits) a list.
# wide.legend, high.legend: point at which to start printing first legend item
# Specify as a fraction of the x- or y-distance.
# expand.y: e.g. 25% will increase the upper y-limit to give 25% extra space 
# for legend etc.
#
# print.statistics: whether to print out coeffs, ses etc of fitted polynomials
# plot.means, plot.points: means and/or points
# plot.single.sem, plot.groups.sem: strategy for calculating sem
# errors: strategy for calculation of error mean square.
#  "aov" calculates the mean square from the "within x" sum of squares.
#  Alternatives are lack.of.fit (deviations from the fitted polynomial)
#  and total (aov and lack.of.fit combined).
# include: This is a vector of booleans; T where a list element is included.
#
#
    par(new = F)
    options(width = 180)
    var.new <- function(x)
    {
       pres <- !is.na(x)
       var(x[pres])
    }
    date.txt <- unix("date '+DATE: %d/%m/%y %H:%Mh'")
    docs <- paste(unix("pwd"), as.character(as.name(match.call())), date.txt, 
       collapse = "")
    print(docs)
    if(!plotit) {
       if(missing(plot.means))
          plot.means <- F
       if(missing(plot.points))
          plot.points <- F
    }
    plotch <- style$plotch
    lwd <- style$lwd
    cex.title <- style$cex.title
    cex.labels <- style$cex.labels
    mai.xtra <- style$mai.xtra
    if(!is.null(confidence) & !is.null(compare)) {
       cat("\nValues set both for ci's & for comparisons.", 
          "\nCode for both is not implemented at this point.", 
          "\nWill do comparisons only.\n")
       confidence <- NULL
    }
    if(plot.points | plot.means | plotit)
       plot.some <- T
    else plot.some <- F
    xtra <- numeric(0)
    linetype.len <- 0
    oldpar <- par()
    on.exit(par(oldpar))
    par(mai = par()$mai + mai.xtra)
    u <- datafun(lt = lt, choice = choose)
    leg <- u$leg
    ltraw.list <- u$lt
    xval.list <- u$xval
    xlab <- u$xlab
    xaxlab <- u$xaxlab
    yaxlab <- u$yaxlab
    ylab <- u$ylab
    groups <- u$groups
    maint <- u$maint
    if(is.list(maint))
       maint <- paste(maint[["prefix"]], " LT~v~c.8~.", lt, "~h0~c1~.",  , " ",
          maint[["main"]], sep = "")
    else maint <- paste(prefix, maint)
    mean.list <- lapply(xval.list, unique)    
    #Set up structure that has the right shape
    num.list <- mean.list
    uniqx.list <- mean.list
    nlist <- length(xval.list)
    if(is.numeric(include)) {
       tmp <- rep(F, nlist)
       tmp[include] <- T
       include <- tmp
    }
    else if(is.null(include))
       include <- rep(T, nlist)
    else if(length(include) < nlist)
       include <- c(include, rep(F, nlist - length(include)))
    include.parallel <- rep(F, nlist)
    if(!is.null(parallel)) {
       include.parallel[parallel] <- T
       xval.parallel <- list()
       pres.parallel <- list()
       lt.parallel <- list()
       n.parallel <- sum(include.parallel)
       num.parallel <- rep(0, n.parallel)
       wts.parallel <- rep(0, n.parallel)
       df.parallel <- rep(0, n.parallel)
       leg.parallel <- leg[include.parallel]
    }
    if(is.null(groups))
       groups <- as.list((1:nlist)[include])
    ngroups <- length(groups)
    if(nlist > 1 & length(deg) == 1)
       deg.pol <- rep(deg, nlist)
    else deg.pol <- deg
    if(nlist > 1 & length(poly) == 1)
       poly <- rep(poly, nlist)
    if(nlist > 1 & length(splin) == 1)
       splin <- rep(splin, nlist)
    if(!is.list(poly.limits))
       poly.limits <- list(poly.limits)
    if(!is.list(poly.keep.x))
       poly.keep.x <- list(poly.keep.x)
    if(nlist > 1 & length(poly.limits) == 1)
       poly.limits <- rep(poly.limits, nlist)
    if(nlist > 1 & length(poly.keep.x) == 1)
       poly.keep <- rep(poly.keep.x, nlist)
    if(!is.list(poly.plot.limits))
       poly.plot.limits <- list(poly.plot.limits)
    if(nlist > 1 & length(poly.plot.limits) == 1)
       poly.plot.limits <- rep(poly.plot.limits, nlist)
    if(!is.null(wts))
       if(nlist > 1 & length(wts) == 1)
          wts <- rep(wts, nlist)
    xlab <- u$xlab
    if(sum(include) > length(plotch))
       plotch <- c(plotch, letters)
    vm.aov <- array(, nlist)
    vm.other <- array(, nlist)
    df.other <- array(, nlist)
    numdf <- array(, nlist)
    nummin <- array(, nlist)
    nummax <- array(, nlist)
    lt.list <- ltraw.list
    for(i in 1:nlist)
       lt.list[[i]] <- fun(ltraw.list[[i]])
    mat.range <- matrix(unlist(lapply(ltraw.list, range, na.rm = T)), nrow = 2)
    unlist.raw <- unlist(ltraw.list)
    yrange <- range(mat.range[, include], na.rm = T)
    log.y <- F
    if(all(fun(exp(1:4)) == 1:4)) {
       log.y <- T
       mat.range <- matrix(unlist(lapply(ltraw.list, function(x, na.rm = T)
       range(x[x > 0]), na.rm = T)), nrow = 2)
       yrange[1] <- min(mat.range, na.rm = T)
       yrange[1] <- min(unlist.raw[unlist.raw > 0], na.rm = T)
    }
    if(is.null(y.limits)) {
       funrange <- fun(yrange)
       y.limits <- yrange
    }
    else funrange <- fun(y.limits)
    funrange[2] <- funrange[2] + diff(funrange) * expand.y    
    # Often set expand.y = 0.05 or 0.1, to allow room for legend
    if(is.null(yaxlab)) {
       ylabels <- pretty(y.limits)
       if(all(fun(exp(1:4)) == 1:4)) {
          splity <- sqrt(y.limits[1] * y.limits[2])
          ylabels2 <- pretty(c(splity, max(y.limits)), 4)
          ylabels1 <- pretty(c(min(y.limits), splity), 4)
          ylabels <- sort(unique(c(ylabels1, ylabels2)))
          if(ylabels[1] == 0)
             ylabels[1] <- mean(ylabels[1:2])
       }
    }
    else ylabels <- yaxlab
    ncharwid <- max(nchar(paste(ylabels)))
    ylabadd <- (ncharwid - 1.5) * 0.25
    ytitladd <- (1.25 * ncharwid - 2) * 0.125
    if(plot.some) {
       if(is.null(x.limits))
          x.limits <- range(unlist(xval.list), na.rm = T)
       plot(x.limits, funrange, xlim = x.limits, type = "n", xlab = "", xaxt = 
          "n", ylab = "", yaxt = "n")
       if(is.null(xaxlab))
          xaxlab <- pretty(x.limits)
       axis(1, at = xaxlab)
       axis(2, at = fun(ylabels), labels = paste(ylabels), mgp = c(3 + ytitladd,
          1 + ylabadd, 0))
       chh <- par()$cxy[2]
       chw <- par()$cxy[1]
       uxy <- par()$usr
    }
    outvals <- vector("list", sum(include))
    names(outvals) <- names(lt.list)[include]
    i.plot <- 0
    j.parallel <- 0
    for(i in 1:nlist)
       if(include[i]) {
          u.x <- NULL
          bt.y <- NULL
          i.plot <- i.plot + 1
          deg.i <- deg.pol[i]
          pres <- !is.na(lt.list[[i]])
          if(all(!pres))
             next
          temps <- xval.list[[i]][pres]
          ltval <- lt.list[[i]][pres]
          if(plot.points)
             points(temps, ltval, pch = plotch[i.plot], mkh = 0.75 * mkh, lwd
                 = lwd)
          vv <- tapply(ltval, list(temps), var)
          my <- tapply(ltval, list(temps), mean)
          tab.temps <- table(temps)
          utemps <- as.numeric(names(tab.temps))
          num <- as.numeric(tab.temps)
          num.list[[i]] <- num
          uniqx.list[[i]] <- utemps
          if(!na.means) {
             my.test.na <- tapply(lt.list[[i]], list(xval.list[[i]]), function(
                x)
             any(is.na(x)))
             utemps.all <- unique(xval.list[[i]])
             utemps.na <- utemps.all[my.test.na]
             if(length(utemps.na) > 0) {
                u.match <- match(utemps.na, utemps, nomatch = 0)
                if(any(u.match > 0))
                   my[u.match] <- NA
             }
             mean.list[[i]] <- my
          }
          if(plot.means)
             points(utemps, my, pch = plotch[i.plot], mkh = mkh, lwd = 2)
          nummin[i] <- min(num[!is.na(my)])
          nummax[i] <- max(num[!is.na(my)])
          sd <- sqrt(vv)
          sem <- sd/sqrt(num)
          df.aov.rss <- sum(num - 1)
          numdf[i] <- df.aov.rss
          ms.aov <- sum(vv * (num - 1), na.rm = T)/df.aov.rss
          vm.aov[i] <- ms.aov
          sd.aov <- sqrt(ms.aov)
          cat("\n", leg[i], "  ", date(), fill = T)
          av.se <- data.frame(rbind(format(round(my, 2)), format(round(sem, 2)),
             num))
          row.names(av.se) <- c("Means are:", "sem's are:", "Nos.")
          names(av.se) <- paste(utemps)
          print(av.se)
          cat("sds are", format(round(sd, 2)))
          if(df.aov.rss > 0)
             cat("  pooled:", format(round(sd.aov, 3)), "  df =", df.aov.rss, 
                fill = T)
          if(log.y) {
             btmeans <- exp(my)
             btsem <- btmeans * sem
             bt.se <- data.frame(rbind(format(round(btmeans, 1)), format(round(
                btsem, 2))))
             row.names(bt.se) <- c("BT means:", "Appr sem:")
             names(bt.se) <- paste(utemps)
             print(bt.se)
          }
          cat("\n", fill = T)
          rtemps <- range(temps)
          utemps <- uniqx.list[[i]]
          poly.i <- poly[i]
          if(poly.i)
             linetype.len <- 3.5
          splin.i <- splin[i]
          if(poly.i & length(utemps) <= deg.i) {
             if(length(utemps) > 1)
                cat("*** Insufficient points for polynomial  of degree", deg.i,
                   fill = T)
             poly.i <- F
          }
          if(splin.i & length(utemps) < 4) {
             if(length(utemps) > 1)
                cat(
                   "*** Insufficient points for spline -- at least 4 are required",
                   fill = T)
             splin.i <- F
          }
          poly.lim <- poly.limits[[i]]
          poly.keep <- poly.keep.x[[i]]
          if(is.null(poly.lim))
             poly.lim <- rtemps
          else if(any(is.na(match(poly.lim, utemps))))
             cat(
                "One or both endpoints for the polynomial fit do not match actual data values",
                fill = T)
          if(length(poly.lim) == 1 & is.null(poly.keep)) {
             cat("Only one limit has been given; cannot fit quadratic", fill = 
                T)
             poly.lim <- rep(poly.lim, 2)
          }
          if(is.null(poly.keep)) {
             keep <- (utemps >= poly.lim[1] & utemps <= poly.lim[2])
             poly.keep <- utemps[keep]
          }
          else keep <- as.logical(match(utemps, poly.keep, nomatch = F))
          nu <- (1:length(utemps))[keep]
          y.means <- my[nu]
          x.means <- utemps[nu]
          yfit <- my
          use.quad <- as.logical(match(temps, poly.keep, nomatch = F))
          x.quad <- temps[use.quad]
          y.quad <- ltval[use.quad]
          num.quad <- num[nu]
          df.quad <- sum(num.quad - 1)
          if(df.quad == 0)
             ms.quad <- 0
          else ms.quad <- sum(vv[nu] * (num.quad - 1), na.rm = T)/df.quad
          ems <- ms.quad
          df.t <- df.quad
          if(poly.i) {
             poly.legend <- "Polynomial"
             if(fit.robust)
                poly.legend <- "Polynomial (robust fit)"
             if(!is.null(poly.keep.x[[i]]))
                cat(poly.legend, "of degree", deg.i, "through points", 
                   poly.keep, fill = T)
             else cat(poly.legend, "of degree", deg.i, "from points", poly.lim[
                   1], "to", poly.lim[2], fill = T)
             uu <- poly.fit(x.quad, y.quad, num.quad, deg.i, ms.quad, df.quad, 
                errors, print.statistics = print.statistics, predict.x = 
                predict.x, fit.robust = fit.robust, wts = wts)
             ypred.se <- uu$pred$se.fit
             df.t <- uu$df.ms
             xtra <- uu$xtra
             ems <- uu$ems
             vm.other[i] <- ems
             df.other[i] <- df.t
             df.t0 <- uu$pred$df
             ems0 <- uu$pred$ms
             if(!is.null(df.t0))
                if(df.t != df.t0)
                   cat("\n ******* df.t =", df.t, "   df.t0 =", df.t0, "\n")
             if(!is.null(ems0)) if(ems != ems0) {
                   cat("****** Warning ******\n")
                   cat("ems =", ems, "   ems0 =", ems0, "\n\n")
                }
# vanilla ms; depends on errors
             b <- uu$b
             if(include.parallel[i]) {
                j.parallel <- j.parallel + 1
                xval.parallel[[j.parallel]] <- x.quad
                lt.parallel[[j.parallel]] <- y.quad
                num.parallel[j.parallel] <- sum(num[nu])
                wts.parallel[j.parallel] <- 1/ems
                df.parallel[j.parallel] <- df.t
             }
             if(!is.null(predict.x)) {
                ypred <- uu$pred$fit
                u.x <- predict.x
                if(!is.null(confidence)) {
                   alpha <- 1 - confidence
                   c.txt <- paste(round(confidence * 100))
                   c.txt1 <- NULL
                   t.stat <- qt(1 - alpha/2, df.t)
                }
                else if(!is.null(compare)) {
                   alpha <- 1 - compare
                   t.stat <- qt(1 - alpha/2, df.t)/sqrt(2)
                   c.txt <- format(round((2 * pt(t.stat, df.t) - 1) * 100, 1))
                   c.txt1 <- paste(round((1 - compare) * 100))
                }
                ci.low <- ypred - ypred.se * t.stat
                ci.high <- ypred + ypred.se * t.stat
                if(log.y) {
                   bt.y <- exp(ypred)
                   bt.sem <- bt.y * ypred.se
                   xx <- data.frame(rbind(format(round(bt.y, 1)), format(signif(
                      exp(ci.low), 3)), format(signif(exp(ci.high), 3)), format(
                      signif(bt.sem, 2))))
                   dimnames(xx) <- list(c("BT preds:", paste(c.txt, "pc low:", 
                      sep = ""), paste(c.txt, "pc high:", sep = ""), 
                      "Approx sem:"), paste(u.x))
                   print(xx)
                   if(!is.null(c.txt1))
                      cat("\nNon-overlap of ci's is equivalent to a test for", 
                         "\nno difference at the", paste(c.txt1, "pc", sep = ""
                         ), "level.\n")
                }
                else {
                   cat("\nTemps   :", format(round(u.x, 1)), fill = T)
                   cat("Pred vals:", format(round(ypred, 1)), fill = T)
                   cat("Appr. sem:", format(round(ypred.se, 2)), fill = T)
                   bt.y <- ypred
                }
             }
             sem[nu] <- sqrt(ems/num.quad)
             if(length(nu) < length(utemps) & errors == "aov") {
                ms.other <- sum(vv[ - nu] * (num[ - nu] - 1), na.rm = T)/sum(
                   num[ - nu] - 1)
                sem[ - nu] <- sqrt(ms.other/num[ - nu])
             }
          }
          if(plot.single.sem)
             errorbars(utemps, my, sem, 0.25 * chw)
          if(poly.i) {
             if(is.null(poly.plot.limits[[i]]))
                xpoints <- pretty(utemps[nu], 50)
             else xpoints <- pretty(poly.plot.limits[[i]], 50)
             yfit[nu] <- rep(b[1], length(nu))
             yhat <- rep(b[1], length(xpoints))
          }
          if(poly.i)
             if(deg.i > 0)
                for(k in 2:(deg.i + 1)) {
                   yfit[nu] <- yfit[nu] + b[k] * utemps[nu]^(k - 1)
                   yhat <- yhat + b[k] * xpoints^(k - 1)
                }
          if(plot.some) {
             if(poly.i & !splin.i)
                lines(xpoints, yhat, lty = i.plot, lwd = lwd)
             if(plot.ci) {
                lines(spline(u.x, ci.low), lty = i.plot)
                lines(spline(u.x, ci.high), lty = i.plot)
             }
          }
          if(splin.i) {
# spline; perhaps polynomial through points between poly.limits
             if(diff(rtemps) > diff(range(utemps[nu]))) cat(
                   "Extend polynomial to the whole range of x-values as a spline curve.",
                   fill = T)
             if(length(utemps) >= 3) {
                uus <- spline(utemps, yfit)
                xpoints <- uus$x
                yhat <- uus$y
                if(length(xtra) > 3) {
                   xtrafit <- approx(uus$x, uus$y, xout = xtra)$y
                   if(log.y)
                      xtrafit <- exp(xtrafit)
                   names(xtrafit) <- paste(xtra)
                   cat("\n Predictions from spline fit:\n")
                   print(round(xtrafit, 2))
                }
                if(plot.some)
                   lines(xpoints, yhat, lty = i.plot)
             }
          }
          if(!is.null(u.x) & !is.null(bt.y))
             outvals[[i.plot]] <- cbind(u.x, bt.y)
       }
# Parallel curve analysis, if requested
# At present, lines are the only option (no plots)
    if(!is.null(parallel)) {
       cat("\nParallel line or curve analysis", fill = T)
       cat("Factors are:", leg.parallel, fill = T)
       deg.here <- max(deg.pol[include.parallel])
       x.all <- unlist(xval.parallel)
       y.all <- unlist(lt.parallel)
       wts.all <- rep(wts.parallel, num.parallel)
       id.parallel <- rep(1:n.parallel, num.parallel)
       f.parallel <- factor(id.parallel, labels = leg.parallel)
       u.parallel <- lm(lt ~ C(stage, treatment) + temp, data = list(lt = y.all,
          temp = x.all, stage = f.parallel, wts = wts.all, deg.here = deg.here),
          weights = wts)
       u.one <- lm(lt ~ temp, data = list(lt = y.all, temp = x.all, stage = 
          f.parallel, wts = wts.all, deg.here = deg.here), weights = wts)    
    #		print(summary(u.one,correl=F))
       print(summary(u.parallel, correl = F))
       print(anova(u.one, u.parallel), test = "F")
    }
    semin <- array(, ngroups)
    semax <- array(, ngroups)
    groupsd <- array(, nlist)
    for(k in 1:ngroups) {
       sublist <- groups[[k]]    # N.B. May have >1 list item per group
       leg.k <- paste(leg[sublist], collapse = "; ")
       if(!any(include[sublist])) {
          cat("** List nos.", sublist, "have been specified", 
             "\nOne or more of these is not in the include list", fill = T)
          break
       }
       nmin <- min(nummin[sublist])
       nmax <- max(nummax[sublist])
       sd.aov <- sqrt(sum(vm.aov[sublist] * numdf[sublist], na.rm = T)/sum(
          numdf[sublist]))
       sd.other <- sqrt(sum(vm.other[sublist] * df.other[sublist], na.rm = T)/
          sum(df.other[sublist]))
       if(is.na(sd.other))
          next
       if(errors == "aov" & sum(numdf[sublist]) == 0 & poly.i)
          errors.here <- "lack.of.fit"
       else errors.here <- errors
       sd.points <- switch(errors.here,
          aov = sd.aov,
          lack.of.fit = ,
          total = sd.other)
       groupsd[k] <- sd.points
       if(length(sublist) > 1) {
          cat("\nGroup together lists", sublist, fill = T)
          cat("   Overall pooled sd =", format(round(sd.points, 3)), fill = T)
       }
       semax[k] <- sd.points * sqrt(1/nmin)
       semin[k] <- sd.points * sqrt(1/nmax)
       cat("\n", leg.k, ":")
       if(nmax > nmin)
          cat("sem = Max:", format(round(semax[k], 3)), "    Min:", format(
             round(semin[k], 3)), fill = T)
       else cat("sem =", format(round(semax[k], 3)), fill = T)
    }
    if(plot.some) {
       if(plot.groups.sem)
          if(ngroups > 1) {
             se.tmp <- semax
             se.tmp[is.na(se.tmp)] <- 0.55000000000000004 * chh
             se.last <- se.tmp[ngroups]
             se.two <- se.tmp + c(0, se.tmp[ - ngroups]) + 0.40000000000000002 *
                chh
             if(length(legend.linespace) == 1) legend.linespace <- se.two/chh
        
    # Can get spacing from parameter legend.linespace by making this a vector
          }
       x.legend <- uxy[1] + diff(uxy[1:2]) * wide.legend + chw
       if(wide.legend == 1)
          x.legend <- uxy[2] - linetype.len * chw - max(nchar(leg)) * chw
       y.legend <- uxy[3] + diff(uxy[3:4]) * high.legend - chh
       if(high.legend == 1) {
          y.legend <- uxy[4] - 0.5 * chh
       }
       if(high.legend == 0)
          y.legend <- uxy[1] + se.last + sum(se.two)
       xpos <- rep(x.legend, length(leg))
       ypos <- y.legend - cumsum(legend.linespace) * chh
    }
    j0 <- 0
    if(plot.groups.sem)
       for(k in 1:ngroups) {
          sd.here <- groupsd[k]
          sublist <- groups[[k]]
          if(legend.sem) {
             j0 <- j0 + 1
             sem.max <- semax[k]
             sem.min <- semin[k]
             errorbars(xpos[j0] - 1.25 * chw, ypos[j0], sem.max, eps = chw/2)
             pretext.pos <- xpos[j0] - 2.5 * chw
             if(!is.na(sem.min) & sem.min < 0.75 * sem.max) {
                errorbars(xpos[j0] - 3 * chw, ypos[j0], sem.min, eps = chw/2)
                pretext.pos <- xpos[j0] - 4.25 * chw
             }
             if(j0 == 1)
                text(pretext.pos, ypos[j0], bars.pretext, adj = 1)
          }
          for(jk in sublist) {
             mv <- mean.list[[jk]]
             num <- num.list[[jk]]
             sem <- sd.here/sqrt(num)
             uniqx <- uniqx.list[[jk]]
             if(!legend.sem)
                errorbars(uniqx, mv, sem, eps = chw/2)
          }
       }
    if(!plot.some)
       return()
    note.pos <- ypos[j0] - 1 * chh
    if(plot.groups.sem)
       note.pos <- note.pos - semax[length(semax)]
    if(nchar(legend.note) > 0)
       text(xpos[1], note.pos, legend.note, adj = 0, cex = 0.75)
    oldmgp <- par(mgp = c(2.75 + ytitladd, 0.5, 0))$oldmgp
    if(names(dev.cur()) == "postscript")
       mixed.mtext(texts = paste(prefix.y, "LT~v~c.8~.", lt, "~h0~c1~. ", ylab,
          sep = ""), side = 2, line = 2.5 + ytitladd, adj = 0.5, cex = 
          cex.labels)
    else mtext(text = paste(prefix.y, "LT", lt, " ", ylab, sep = ""), side = 2,
          line = 2.5 + ytitladd, adj = 0.5, cex = cex.labels)
    par()$oldmgp
    if(length(leg) < nlist) {
       cat("Insufficient legends", fill = T)
       leg <- c(leg, rep("", nlist - length(leg)))
    }
    else if(length(leg) > nlist)
       cat("NB: There are superfluous legends", fill = T)
    if(length(leg) < nlist)
       cat("Insufficient legends", fill = T)
    j0 <- 0
    if(sum(include) > 1) {
       for(i in 1:nlist)
          if(include[i]) {
             j0 <- j0 + 1
             points(xpos[j0], ypos[j0], pch = plotch[j0], cex = 
                0.90000000000000002, mkh = mkh)
             if(poly[i])
                lines(c(xpos[j0] + 1.5 * chw, xpos[j0] + (linetype.len + 1.5) * 
                   chw), c(ypos[j0], ypos[j0]), lty = j0)
             if(names(dev.cur()) == "postscript")
                mixed.text(xpos[j0] + (linetype.len + 2) * chw, ypos[j0], leg[i
                   ], adj = 0, cex = 0.80000000000000004)
             else text(xpos[j0] + (linetype.len + 2) * chw, ypos[j0], leg[i], 
                   adj = 0)
          }
    }
    if(is.null(xlab)) {
       xlab <- ""
       cat("No setting was provided for xlab\n")
    }
    if(names(dev.cur()) == "postscript") {
       mixed.mtext(texts = paste(xlab, sep = ""), side = 1, line = 2.25, adj = 
          0.5, cex = cex.labels)
       if(maint != "")
          mixed.mtext(texts = maint, side = 3, line = 1.75, adj = 0.5, cex = 
             cex.title)
    }
    else {
       mtext(paste(xlab, sep = ""), 1, line = 2.25, cex = cex.labels)
       mtext(text = maint, side = 3, line = 1.75, adj = 0.5, cex = cex.title)
    }
    oldcex <- par(cex = 0.40000000000000002)
    r.txt <- unix("date +%d/%m/%y'  '%H:%M")
    l.txt <- paste(unix("pwd"), as.character(as.name(match.call())), collapse
        = "")    
    #	docs <- paste(unix("pwd"), as.character(as.name(match.call())), 
#		date.txt, collapse = "")
    if(datestamp) {
       mtext(r.txt, side = 1, adj = 1, outer = T, line = mtext.line)
       mtext(l.txt, side = 1, adj = 0, outer = T, line = mtext.line)
    }
    options(width = 80)    #	docs
    invisible()
}
pool.adj <-
function(x, r, n, phat, cm, cm.strategy = "adjust.later", cm.code = NULL, 
    cm.allcodes = NULL, plimits = c(0.0025000000000000001, 0.99950000000000006),
    plotit = "loess", link = "loglog", xfun = function(x)
x, legend = "", x.cm = NULL, dead.cm = NULL, tot.cm = NULL, xtit = "Time", ytit
     = NULL, mkh = 0.025000000000000001, extrap.low = 0.25, extrap.high = 0.25,
    span = 1, deg = 1, lo.lty = 2, lwd = 1, n.lo = 50, title.line = 0.25)
{
# pool.adj is called both by fitconf and by flyplot
#
# extrap.low (extrap.high) is fraction
# of range allowed for extrapolation below (above)
# These are halved if there are just two points
    if(!is.null(plotit)) {
       plotit[plotit == "loess"] <- "mono.loess"
       plotit[plotit == "mono"] <- "mono.loess"
       show.curve <- as.logical(match(c("mono.line", "mono.loess"), plotit, 
          nomatch = 0))
    }
    else show.curve <- rep(F, 2)
    if(!is.null(phat)) {
       phat.strategy <- names(phat)
       new.lt <- T
       lt <- array(NA, length(phat))
       nam.lt <- names(phat)
       ab <- vector("list", length(phat))
    }
    else {
       lt <- NULL
       ab <- NULL
       new.lt <- F
       phat.strategy <- ""
    }
    plot.some <- any(show.curve)
    if(all(xfun(exp(1:8)) == 1:8)) {
       xfun.inv <- exp
       takelog <- T
    }
    else {
       xfun.inv <- function(x)
       x
       takelog <- F
    }
    if(any(diff(x)) < 0)
       stop("** Monotone fitting requires that data is ordered by x-values **")
    x0 <- x
    r0 <- r
    n0 <- n
    p0 <- r0/n0
    if(any(diff(x) == 0)) {
       r <- tapply(r, x, sum)
       n <- tapply(n, x, sum)
       x <- as.numeric(names(r))
    }
    if(takelog)
       if(any(x <= 0)) {
          x.0 <- x > 0
          x <- x[x.0]
          r <- r[x.0]
          n <- n[x.0]
       }
    g <- link.function(link)
    nn <- length(n)
    p <- r/n
    if(is.null(cm)) {
       cat("\nNo control mortality was supplied.\n")
       cat("\nFor monotone estimation set cm = 0\n")
    }
    if(cm.strategy == "adjust.later" & !is.null(phat))
       ptarg <- cm + ((1 - cm) * phat)/100
    id <- 1:nn
    repeat {
       i <- 2
       while(i <= nn && p[id[i]] >= p[id[i - 1]]) i <- i + 1
       if(i <= nn) {
          x[id[i - 1]] <- x[id[i]] <- (n[id[i - 1]] * x[id[i - 1]] + n[id[i]] * 
             x[id[i]])/(n[id[i - 1]] + n[id[i]])
          r[id[i - 1]] <- r[id[i]] <- r[id[i]] + r[id[i - 1]]
          n[id[i - 1]] <- n[id[i]] <- n[id[i]] + n[id[i - 1]]
          p[id[i - 1]] <- p[id[i]] <- r[id[i]]/n[id[i]]
          idi <- id[i]
          while(i <= nn && id[i] == idi) {
             id[i] <- id[i - 1]
             i <- i + 1
          }
       }
       else break
    }
    n1 <- max((1:nn)[p == 0])
    if(!is.na(n1))
       id <- id[id >= n1]
    use <- unique(id)
    ux <- x[use]
    ux.tran <- xfun(ux)
    if(!is.null(phat))
       ptarg.interp <- ptarg
    r.use <- r[use]
    n.use <- n[use]
    p.use <- r.use/n.use
    if(cm.strategy == "abbott") {
       here.use <- p.use >= cm
       use <- use[here.use]
       ux <- ux[here.use]
       ux.tran <- xfun(ux)
       p.use <- (p.use[here.use] - cm)/(1 - cm)
    }
    xx <- cbind(r[use], (n - r)[use])
    p.max <- max(p.use)
    p.min <- min(p.use)
    done.loess <- F
    show.line <- show.curve[1]
    show.loess <- show.curve[2]
    nx <- sum(p.use < 1)
    n01 <- sum(p.use > 0 & p.use < 1)
    phat.strategy[phat.strategy == "mono"] <- "loess"
    phat.strategy[phat.strategy == "mono.loess"] <- "loess"
    calc.loess <- any(as.logical(match("loess", phat.strategy, nomatch = 0)))
    if(length(ux) >= 4 & nx >= 3 & (show.loess | calc.loess) & n01 >= 2) {
       gp <- g(p.use)
       assign("df.lo", data.frame(y = p.use, x = ux.tran, n = n.use), frame = 1
          )
       assign("span", span, frame = 1)
       assign("deg", deg, frame = 1)
       u <- switch(link,
          identity = gam(y ~ lo(x, span = span, degree = deg), family = 
             binomial("identity"), data = df.lo, weight = n),
          logsurv = ,
          log = gam(y ~ lo(x), family = binomial("log"), data = df.lo, weight
              = n, span = span, degree = deg),
          logit = gam(y ~ lo(x, span = span, degree = deg), family = binomial(
             "logit"), data = df.lo, weight = n),
          sqrt = gam(y ~ lo(x, span = span, degree = deg), family = binomial(
             "sqrt"), data = df.lo, weight = n),
          inverse = gam(y ~ lo(x, span = span, degree = deg), family = binomial(
             "inverse"), data = df.lo, weight = n),
          probit = gam(y ~ lo(x, span = span, degree = deg), family = binomial(
             "probit"), data = df.lo, weight = n),
          cloglog = ,
          loglog = gam(y ~ lo(x, span = span, degree = deg), family = binomial(
             "cloglog"), data = df.lo, weight = n))
       assign("df.new", data.frame(x = pretty(ux.tran, n.lo)), frame = 1)
       hat.u <- predict(u)
       u.lo <- loess(y ~ x, data = list(y = hat.u, x = ux.tran), span = span, 
          deg = deg, span = span)    # If no. of points is 4 and span<1, 
# the fitted curve has a tendency to oscillate up and down
       hat.loess <- predict(u.lo, newdata = df.new)
       range.loess <- range(hat.loess, na.rm = T)
       done.loess <- T
    }
    else done.loess <- F
    for(i in seq(along = phat)) {
       if(n01 < 2)
          break
       pc <- ptarg[i]
       yhat <- g(pc)
       get.lt <- as.logical(match(c("line", "loess"), phat.strategy[i], nomatch
           = 0))
       lt.line <- get.lt[1]
       lt.loess <- get.lt[2]
       pc.interp <- ptarg.interp[i]
       yhat.interp <- g(pc.interp)
       alt.line <- F
       if(!done.loess || yhat.interp < range.loess[1] || yhat.interp > 
          range.loess[2])
          alt.line <- T
       mn.use <- 1:length(use)
       if(any(r.use < n.use))
          n.ones <- max(mn.use[r.use < n.use]) + 1
       else n.ones <- mn.use[1]
       take.above <- (r.use > n.use * pc) & (mn.use <= n.ones)
       take.low <- r.use <= n.use * pc
       if(lt.line | (alt.line & lt.loess))
          if(sum(take.above) >= 1) {
             mn.above <- mn.use[take.above]
             n.above <- min(c(max(mn.above), min(mn.above) + 2))
             n.low <- max(c(1, n.above - 3))
             if(n.low == 1)
                n.above <- min(c(max(mn.above), min(mn.above) + 3))
          }
          else if(sum(take.low) >= 1) {
             mn.low <- mn.use[take.low]
             n.above <- max(mn.low)
             n.low <- max(c(mn.low[1], n.above - 3))
          }
          else {
             lt.line <- F
             alt.line <- F
          }
       if(lt.line | alt.line) {
          p.here <- p.use[n.low:n.above]
          not.one <- sum(p.here < 1)
          g.here <- g(p.here)
          g.interp <- g(pc.interp)
          n.span <- n.above - n.low + 1
          eps.low <- extrap.low * diff(range(g.here))
          eps.high <- extrap.high * diff(range(g.here))
          if(n.span == 2) {
             eps.low <- eps.low/2
             eps.high <- eps.high/2
          }
          if(n.span >= 2 & not.one > 1)
             show.line <- ((max(g.here) > pc.interp - eps.high & min(g.here) < 
                pc.interp) | (min(g.here) < pc.interp + eps.low & max(g.here) > 
                pc.interp))
          else {
             show.line <- F
             lt.line <- F
             alt.line <- F
          }
       }
       if(lt.line | (alt.line & lt.loess)) {
          rn <- xx[n.low:n.above,  ]
          xv <- xfun(ux[n.low:n.above])
          u <- switch(link,
             identity = glm(y ~ x, family = robust(binomial("identity")), data
                 = list(y = rn, x = xv)),
             logsurv = ,
             log = glm(y ~ x, family = robust(binomial("log")), data = list(y
                 = rn, x = xv)),
             logit = glm(y ~ x, family = robust(binomial("logit")), data = list(
                y = rn, x = xv)),
             sqrt = glm(y ~ x, family = robust(binomial("sqrt")), data = list(y
                 = rn, x = xv)),
             inverse = glm(y ~ x, family = robust(binomial("inverse")), data = 
                list(y = rn, x = xv)),
             probit = glm(y ~ x, family = robust(binomial("probit")), data = 
                list(y = rn, x = xv)),
             cloglog = ,
             loglog = glm(y ~ x, family = robust(binomial("cloglog")), data = 
                list(y = rn, x = xv)))
          if(!is.na(u$coef[2]) & (lt.line | (alt.line & lt.loess)) & u$coef[2] >
             0) {
             lt[i] <- xfun.inv((yhat - u$coef[1])/u$coef[2])
             ab[[i]] <- u$coef[1:2]
             nam.lt[i] <- "line"
          }
          else {
             lt[i] <- NA
             ab <- NULL
          }
       }
       if(done.loess && lt.loess && min(hat.loess, na.rm = T) <= yhat && max(
          hat.loess, na.rm = T) >= yhat) {
          here.hat <- !is.na(hat.loess)
          lt[i] <- xfun.inv(approx(x = hat.loess[here.hat], y = df.new$x[
             here.hat], xout = yhat.interp)$y)
          nam.lt[i] <- "mono"
       }
    }
    if(new.lt & !is.null(phat)) {
       p.txt <- paste("LT", phat, "=", format(round(lt, 1)), sep = "")
       leg <- paste(legend, " [", paste(p.txt, collapse = "; "), "]", sep = "")
       names(lt) <- nam.lt
    }
    else leg <- legend
    if(plot.some) {
       if(!is.null(x.cm)) {
          x0 <- c(paste(x0), x.cm)
          r0 <- c(r0, dead.cm)
          n0 <- c(n0, tot.cm)
       }
# NB x0, r0, n0 do not appear below
       simplot(x = x0, resp = r0, tot = n0, fun = link, cm.strategy = 
          cm.strategy, cm = cm, cm.code = cm.code, cm.allcodes = cm.allcodes, 
          xtit = xtit, ytit = ytit, mkh = mkh, xfun = xfun, main = leg, 
          title.line = title.line, plimits = plimits, points.lwd = lwd)
       yp <- g(plimits)
       for(j in seq(along = ab))
          abline(ab[[j]], lty = i)
       if(done.loess) {
          here <- hat.loess >= yp[1] & hat.loess <= yp[2]
          lines(df.new$x[here], hat.loess[here], lty = lo.lty, lwd = lwd)
       }
    }
    lt
}
ppaste <-
function(...)
{
    paste(..., sep = "")
}
print.function <-
function(func, pos = 1)
{
# To print to screen (usually) a function with its directory, date, etc
    fun.text <- as.character(substitute(func))
    if(pos == 1)
       direc <- paste(unix("pwd"), "/.Data/", sep = "")
    else direc <- paste(search()[pos], "/", sep = "")
    file.info <- unix(paste("ls -la ", direc, fun.text, sep = ""))
    show.info <- substring(file.info, 41, nchar(file.info))
    cat(show.info)
    cat("\n\n")
    cat(fun.text)
    cat("\n")
    func
}
ps.colors <-
structure(.Data = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 
    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
    37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 0, 0.020833333333333332,
    0.041666666666666664, 0.0625, 0.083333333333333329, 0.10416666666666666, 
    0.125, 0.14583333333333331, 0.16666666666666666, 0.1875, 
    0.20833333333333331, 0.22916666666666666, 0.25, 0.27083333333333331, 
    0.29166666666666663, 0.3125, 0.33333333333333331, 0.35416666666666663, 
    0.375, 0.39583333333333331, 0.41666666666666663, 0.4375, 
    0.45833333333333331, 0.47916666666666663, 0.5, 0.52083333333333326, 
    0.54166666666666663, 0.5625, 0.58333333333333326, 0.60416666666666663, 
    0.625, 0.64583333333333326, 0.66666666666666663, 0.6875, 
    0.70833333333333326, 0.72916666666666663, 0.75, 0.77083333333333326, 
    0.79166666666666663, 0.8125, 0.83333333333333326, 0.85416666666666663, 
    0.875, 0.89583333333333326, 0.91666666666666663, 0.9375, 
    0.95833333333333326, 0.97916666666666663, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), .Dim = c(49, 4), .Dimnames = list(
    character(0), c("nos", "all.kullas", "all.shades", "")))
ps.colorsssss <-
structure(.Data = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 
    18, 19, 20, 21, 22, 23, 24, 25, 0, 0.5, 0.83333333333333337, 
    0.33333333333333331, 0.083333333333333329, 0.58333333333333337, 
    0.16666666666666666, 0, 0.5, 0.83333333333333337, 0.33333333333333331, 
    0.083333333333333329, 0.58333333333333337, 0.16666666666666666, 0, 0, 0, 0,
    0, 0, 0.66666666666666663, 0.66666666666666663, 0.66666666666666663, 
    0.66666666666666663, 0.66666666666666663, 0, 1, 1, 1, 1, 1, 1, 1, 0.5, 0.5,
    0.5, 0.5, 0.5, 0.5, 0.5, 1, 0.80000000000000004, 0.59999999999999998, 
    0.40000000000000002, 0.20000000000000001, 0.20000000000000001, 
    0.40000000000000002, 0.59999999999999998, 0.80000000000000004, 1, 0, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), .Dim = 
    c(25, 4))
ps.print <-
function(plot.commands, thickness = 1, hor = F, psz = 14, file = "", del.omi = 
    NULL)
{
# Function used to print directly to printer or postscript file 
# plot.commands is the command string that would plot to a device
# Default is portrait since X11 and motif usually print landscape OK
#  ... but is necessary to print greek characters (i.e. font 13)
    postscript(horizontal = hor, pointsize = psz, file = file)
    if(is.null(del.omi)) {
       if(hor)
          del.omi <- c(10, 75, 10, 75)/25.399999999999999
       else del.omi <- c(-20, 0, 10, 0)/25.399999999999999
    }
    par(lwd = thickness, omi = par()$omi + del.omi)
    on.exit(dev.off(), add = T)
    plot.commands
}
pseudo.f <-
function(y, show.aov = F)
{
# Calculates pseudo F-statistics from an anova of a glm object y
    x <- anova(y)
    bits <- unlist(dimnames(x)[[1]])
    resid.df <- x[rev(bits)[1], "Resid. Df"]
    out.df <- NULL
    for(i in bits[-1]) {
       f.stat <- (x[i, "Deviance"]/x[i, "Df"])/(x[rev(bits)[1], "Resid. Dev"]/
          resid.df)
       prf <- 1 - round(pf(f.stat, x[i, "Df"], resid.df), 3)
       out.df <- rbind(out.df, data.frame(Factor = i, "F value" = round(f.stat,
          4), Df1 = x[i, "Df"], Df2 = resid.df, Prob = prf))
    }
    if(show.aov) {
       print(x)
       cat("\n")
    }
    out.df
}
qik.sum <-
function(df, cols = 1:4, ordered = F)
{
# Does a quick summary, first coercing specified cols to factors and making a matrix
#  into a dataframe.
#
# Requires make.factors() also
    df <- as.data.frame(df)
    summary(make.factors(df, cols, ordered = ordered))
}
relevel <-
function(x, ref, ...)
UseMethod("relevel")
relevel.default <-
function(x, ref, ...)
stop("relevel only for factors")
relevel.factor <-
function(x, ref, ...)
{
    lev <- levels(x)
    nlev <- length(lev)
    if(is.character(ref))
       ref <- match(ref, lev)
    if(is.na(ref))
       stop("ref must be an existing level")
    if(ref < 1 || ref > nlev)
       stop(paste("ref =", ref, "must be in 1 :", nlev))
    factor(x, levels = lev[c(ref, seq(along = lev)[ - ref])], labels = lev[c(
       ref, seq(along = lev)[ - ref])])
}
remove.shading <-
function()
{
# To get rid of shading on shingles above plots
    strip.background <- trellis.par.get("strip.background")
    strip.background$col <- 0
    trellis.par.set("strip.background", strip.background)
    strip.shingle <- trellis.par.get("strip.shingle")
    strip.shingle$col <- 0
    trellis.par.set("strip.shingle", strip.shingle)
}
reorder <-
function(x, y, z)
{
# Reorders a data frame x, so that a column y is now in the order in z
    indx <- NULL
    for(i in z)
       indx <- c(indx, find.pos(i, x[[y]]))
    x[indx,  ]
}
rms <-
function(x, na.rm = T, zero.rm = F)
{
    if(na.rm)
       x <- x[!is.na(x)]
    if(zero.rm)
       x <- x[abs(x) > 0]
    sqrt(mean(x^2))
}
robust.deviance <-
function(phat, n, r, min.expected = 1)
{
# phat : vector of fitted probabilities
# n : binomial totals
# r : binomial successes
# min.expected : groups combined so that minimum number expected 
    eps <- 1.0000000000000001e-15
    if(any(n < 0))
       stop("can't have 0 or negative binomial sample size")
    rhat <- phat * n
    ord <- order(phat)
    ind <- match(1:length(n), ord)
    cum.rhat <- cumsum(rhat[ord])
    g1 <- cum.rhat < min.expected
    g1 <- c(T, g1)[1:length(n)]
    revcum.rhat <- rev(cumsum(rev((n - rhat)[ord])))
    g3 <- revcum.rhat < min.expected
    g3 <- c(g3, T)[-1]
    g2 <- !(g1 | g3)
    df <- sum(g2)    # Really, sum(g2)+2-2; the endpoints are always F
    grp1 <- rep(NA, length(n))
    grp1[g1] <- 1
    grp1[g2] <- 2:(sum(g2) + 1)
    grp1[g3] <- sum(g2) + 2
    grp <- grp1[ind]
    grp
    r.grp <- tapply(r, grp, sum)
    n.grp <- tapply(n, grp, sum)
    phat.grp <- tapply(phat * n, grp, sum)/tapply(n, grp, sum)
    qhat.grp <- 1 - phat.grp
    pobs <- r.grp/n.grp
    qobs <- 1 - pobs
    D1 <- ifelse(pobs < eps, log((pobs/phat.grp)^r.grp), r.grp * log(pobs/
       phat.grp))
    D2 <- ifelse(qobs < eps, log((qobs/qhat.grp)^(n.grp - r.grp)), (n.grp - 
       r.grp) * log(qobs/qhat.grp))
    dev <- 2 * sum(D1 + D2)
    list(dev = dev, df = df)
}
s.tapply <-
function(x, y, z, ...)
{
# Counteracts tapply's propensity to return in sorted index order
#  instead of the order in which they were
    tapply(x, y, z, ...)[(unique(y))]
}
save.new <-
function(x, pos = 2)
{
# To save a new version in a designated position on search list:
# Similar to assign("object",object,frame=1); but immediately writes to database
    assign(as.character(substitute(x)), x, where = pos)
}
sem <-
function(x, na.rm = F)
{
    if(na.rm)
       x <- x[!is.na(x)]
    if(length(x) == 0)
       NA
    else sqrt(var(x)/length(x))
}
set.indentation <-
function(num = c(4, 3), strings = sapply(num, function(n)
paste(rep(" ", n), collapse = "")))
{
# From Tim Hesterberg: makes flexible tab indenting, repeating the last value in num
    strings <- as.character(strings)
    .C("set_indent",
       strings,
       length(strings))
    invisible()
}
set.screens <-
function(across = 2, down = 3, left.margin = 10, top.margin = 20, height = 80, 
    width = 90, ygap = -10, xgap = -1, overwrite = T, centre.x = T, centre.y = 
    T, byrow = T)
{
# Uses split.screen for setting up screens: alternative to par(mfrow/mfcol)
    uu <- ps.region/72 * 25.399999999999999    # Change points to mm
    x.all <- uu[3] - uu[1]
    y.all <- uu[4] - uu[2]    #
# Check if there is room for what has been set
    spare.x <- x.all - across * width - xgap * (across - 1)
    if(spare.x < 0)
       stop("\nInsufficient space:\nCheck left.margin, width and xgap")
    spare.y <- y.all - down * height - ygap * (down - 1)
    if(spare.y < 0) stop(
          "\nInsufficient space:\nCheck top.margin, height and ygap")    #
# Set up coordinates for the screens
    top <- top.margin + ifelse(centre.y, spare.y/(down + 1), 0)
    left <- left.margin + ifelse(centre.x, spare.x/(across + 1), 0)
    N <- across * down
    first.x.corners <- c(left - uu[1], left - uu[1] + width)/x.all
    first.y.corners <- c(uu[4] - top - height, uu[4] - top)/y.all    #browser()
    if(N == 1)
       pos.mat <- matrix(c(first.x.corner, first.y.corner), nr = 1)
    else {
       pos.mat <- NULL
       if(byrow) {
          for(j in 1:down) {
             y.corners.j <- first.y.corners - (ygap + height)/y.all * (j - 1)
             for(i in 1:across) {
                x.corners.i <- first.x.corners + ((width + xgap) * (i - 1))/
                   x.all
                pos.mat <- rbind(pos.mat, c(x.corners.i, y.corners.j))
             }
          }
       }
       else {
          for(i in 1:across) {
             x.corners.i <- first.x.corners + ((width + xgap) * (i - 1))/x.all
             for(j in 1:down) {
                y.corners.j <- first.y.corners - (ygap + height)/y.all * (j - 1
                   )
                pos.mat <- rbind(pos.mat, c(x.corners.i, y.corners.j))
             }
          }
       }
       split.screen(pos.mat, erase = !overwrite)
    }
}
show.nas <-
function(df)
{
# identifies which columns of a dataframe have nas.
#
    sapply(df, function(x)
    any(is.na(x)))
}
sim.beans <-
function(size = 40:300, N = 100)
{
    x <- size
    y <- NULL
    for(i in 1:length(size)) {
       sims <- NULL
       for(j in 1:N) {
          sims[j] <- multi.nom(size[i])
       }
       y[i] <- sum(as.numeric(sims))/N
    }
    plot(x, 1 - y, xlab = "Number in Sample", ylab = 
       "Probability of including every line")
    title("Simulated Sampling from total population of 400")
    abline(0.90000000000000002, 0, lty = 3)
    abline(0.80000000000000004, 0, lty = 4)
}
simplot <-
function(x, resp, tot, fun, cm.strategy = "adjust.later", cm = 0, cm.code = 
    NULL, cm.allcodes = NULL, xtit = "Time in Min", main = "", mkh = 
    0.025000000000000001, xfun = function(x)
x, takelog = F, line = F, ab = c(NA, NA), clip = NULL, xlimits = c(0, 0), 
    xlabels = c(0, 0), offset = 0, title.line = 1, plimits = c(
    0.0025000000000000001, 0.99950000000000006), ytit = NULL, mkh = 
    0.080000000000000002, new = F, lty = 1, plot.char = c(0, 1, 2, 5, 6:16), id
     = NULL, points.lwd = 1)
{
    if(missing(mkh))
       mkh <- par()$cin[2]/3
    if(new)
       par(new = T)
    g <- link.function(fun)
    m <- length(x)
    if(is.null(id))
       id <- 1
    if(length(id) == 1)
       id <- rep(id, length(x))
    if(takelog)
       xfun <- log
    if(all(xfun(exp(1:8)) == (1:8))) takelog <- T    
    # *****************************************************************
    if(is.null(cm.code))
       cm.code <- 0
    if(is.null(cm.allcodes))
       cm.allcodes <- cm.code
    other.rows <- match(x, cm.allcodes, nomatch = 0)
    cm.here.codes <- unique(cm.allcodes[other.rows])
    cmrows <- as.logical(other.rows)
    if(cm.strategy == "adjust.later" & !takelog)
       here.trt <- !cmrows | x == "0"
    else here.trt <- !cmrows
    x.trt <- as.numeric(x[here.trt])
    resp.trt <- resp[here.trt]
    tot.trt <- tot[here.trt]
    id.trt <- id[here.trt]
    if(missing(xlimits))
       xlimits <- range(x.trt)
    if(takelog) {
       if(any(x.trt + offset < 0)) {
          cat(
             "*** Warning: The following x-values have been omitted because\n x"
             )
          if(offset != 0)
             cat("+", offset)
          cat(" < 0:", fill = T)
          cat(format(x.trt[x.trt + offset < 0]), fill = T)
       }
       if(any(x.trt + offset <= 0)) {
          x.logable <- x.trt + offset > 0
          resp.trt <- resp.trt[x.logable]
          tot.trt <- tot.trt[x.logable]
          x.trt <- x.trt[x.logable]
          id.trt <- id.trt[x.logable]
       }
       if(xlimits[1] + offset <= 0)
          xlimits[1] <- min(x.trt[x.trt + offset > 0], na.rm = T)
    }
    if(diff(range(xlabels)) == 0)
       xlabels <- pretty(xlimits)
    if(takelog)
       xlabels <- xlabels[xlabels > 0]
    cat(xlabels, "  ")    # xlabels specifies numeric labels
    p <- resp.trt/tot.trt
    prange <- range(p)
    if(prange[1] < 0 | prange[2] > 1) {
       cat("Error: Smallest p is", prange[1], fill = T)
       cat("     Largest p is", prange[2], fill = T)
       break
    }
    cm0 <- switch(cm.strategy,
       adjust.later = 0,
       abbott = cm)
    here <- p > cm0 & p < 1
    p.adj <- (p - cm0)/(1 - cm0)
    ylow <- g(plimits[1])
    yhigh <- g(plimits[2])
    eps <- (yhigh - ylow) * 0.01
    ylow <- ylow - eps
    yhigh <- yhigh + eps
    labp <- c(1, 5, 25, 50, 75, 95, 99, 99.900000000000006)
    labp <- labp[labp/100 > plimits[1] & labp/100 < plimits[2]]
    aty <- g(labp/100)
    dist <- yhigh - ylow
    if(is.null(ytit)) {
       fun.text <- fun
       ytit <- paste("% Mortality,", fun.text, "scale")
    }
    par(mkh = mkh)
    u.id <- unique(id.trt)
    xlim.here <- xfun(xlimits + offset)
    if(takelog)
       xlim.here <- xlim.here - c(0.115 * diff(xlim.here), 0)
    x.cpos <- xlim.here[1]
    if(sum(here) > 0) {
       plot(xfun(x.trt + offset)[here], g(p.adj[here]), xlim = xlim.here, ylim
           = c(ylow, yhigh), xlab = "", ylab = ytit, axes = F, type = "n")
    }
    else plot(xfun(xlimits + offset), c(ylow, yhigh), xlim = xlim.here, xlab = 
          "", ylab = ytit, axes = F, type = "n")
    midhigh <- 0.5 * (yhigh + par()$usr[4])
    midlow <- 0.5 * (ylow + par()$usr[3])
    chw <- par()$cxy[1]
    chh <- par()$cxy[2]
    j <- 0
    for(i in u.id) {
       j <- j + 1
       here.i <- here & i == id.trt
       g.i <- g(p.adj[here.i])
       if(any(here.i) & any(g.i < ylow | g.i > yhigh)) {
          cat("\n*** One or more points is outside limits set by plimits.***\n"
             )
          cat("\n*** plimits =", format(round(plimits, 4)), "***", "\n")
          cat("\n*** Points are:\n")
          if(any(g.i < ylow)) {
             cat(format(round(p.adj[g.i < ylow], 4)), "\n")
             g.i[g.i < ylow] <- ylow
          }
          if(any(g.i > yhigh)) {
             cat(format(round(p.adj[g.i > yhigh], 4)), "\n")
             g.i[g.i > yhigh] <- yhigh
          }
       }
       if(any(here.i))
          points(xfun(x.trt + offset)[here.i], g(p.adj[here.i]), pch = 
             plot.char[j], mkh = mkh)
       x100 <- x.trt[p == 1 & i == id.trt]
       x0 <- x.trt[p == 0 & i == id.trt]
       x0.100 <- c(x0, x100)
       y0.100 <- c(rep(midlow, length(x0)), rep(midhigh, length(x100)))
       if(length(x0.100) > 0) {
          points(xfun(x0.100 + offset), y0.100, pch = ".", mkh = mkh)
          points(xfun(x0.100 + offset), y0.100, pch = plot.char[j], mkh = mkh)
       }
    }
    if((length(cm.here.codes) > 0) & cm.strategy == "adjust.later") {
       u.cm <- unique(cm.here.codes)
       for(cm.i in u.cm) {
          here.cm <- x == cm.i
          p.cm <- resp[here.cm]/tot[here.cm]
          here.cm <- here.cm[p.cm > 0]
          p.cm <- p.cm[p.cm > 0]
          if(sum(here) > 0)
             text(rep(x.cpos, length(p.cm)), g(p.cm), rep(cm.i, length(p.cm)))
       }
    }
    if(line) {
       b <- ab[2]
       a <- ab[1]
       if(is.na(b))
          b <- -999
       if(is.null(clip))
          clip <- xlimits
       if(b > 0)
          clipline(xfun(clip + offset), c(ylow, yhigh - chh/3), a, b)
    }
    xmax <- max(x.trt)
    epsx <- 0.012500000000000001 * diff(par()$usr[1:2])
    epsy <- 0.012500000000000001 * diff(par()$usr[3:4])
    if(takelog) {
       x.cut1 <- x.cpos + epsx
       x.cut2 <- x.cpos + 2.5 * epsx
       here.pos <- xfun(xlabels + offset) > x.cut2 & xlabels <= xmax
    }
    else here.pos <- xlabels <= xmax
    xpos <- xlabels[here.pos]
    if(length(xpos) <= 2)
       xpos <- xlabels[xlabels <= xmax]
    if(names(dev.cur()) == "postscript" & nchar(main) > 0)
       mixed.mtext(side = 3, line = title.line, texts = main, cex = par()$cex * 
          1.2, adj = 0.5)
    else mtext(side = 3, line = title.line, text = main, cex = par()$cex * 1.2)
    title(xlab = xtit)
    axis(1, at = xfun(xpos + offset), labels = F)
    xusr1 <- par()$usr[1]
    axis(1, at = xfun(xpos + offset), labels = paste(xpos), mgp = c(2, 0.5, 0))
    if(takelog) {
       axis(1, at = c(par()$usr[1], x.cut1), labels = F, tck = 0, mgp = c(2, 
          0.5, 0))
       axis(1, at = c(x.cut2, par()$usr[2]), labels = F, tck = 0, mgp = c(2, 
          0.5, 0))
       lines(x.cut1 + c( - epsx, epsx), par()$usr[3] + 2 * c( - epsy, epsy), 
          xpd = T)
       lines(x.cut2 + c( - epsx, epsx), par()$usr[3] + 2 * c( - epsy, epsy), 
          xpd = T)
    }
    else axis(1, at = par()$usr[1:2], labels = F, tck = 0, mgp = c(2, 0.5, 0))
    pr <- c(1, 5, 20, 50, 80, 99)
    extreme.pr <- c(0, 100)
    npr <- length(pr)
    if(all(g(pr/100) == pr/100))
       identity <- T
    else identity <- F
    if(identity)
       pr <- c(0, 25, 50, 75, 100)
    else pr <- pr[g(pr/100) > ylow & g(pr/100) < yhigh]
    axis(2, at = g(pr/100), labels = paste(pr))
    if(identity) {
       midhigh <- g(1)
       axis(2, at = (0:20)/20, labels = F)
    }
    if(!identity) {
       axis(2, at = c(ylow + 2 * epsy, yhigh - 2 * epsy), labels = F, tck = 0)
       for(k in 1:2) {
          y.end <- c(ylow, yhigh)[k]
          axis(2, at = c(y.end, par()$usr[2 + k]), labels = F, tck = 0)
       }
       kk <- (1:2)[c(length(x0) > 0, length(x100) > 0)]
       for(k in kk) {
          y.mid <- c(midlow, midhigh)[k]
          axis(2, at = y.mid, tck = 0, labels = paste(extreme.pr[k]))
          y.end <- c(ylow, yhigh)[k]
          k <- k + 1
          abline(h = y.end, lty = 2)
          lines(xusr1 + c( - epsx, epsx), c(y.end - 1.5 * epsy, y.end + 1.5 * 
             epsy), xpd = T)
          lines(xusr1 + c( - epsx, epsx), c(y.end - 3.5 * epsy, y.end - 0.5 * 
             epsy), lty = lty, xpd = T)
       }
    }
    else axis(2, at = par()$usr[3:4], labels = F, tck = 0)
    box(bty = "7")
}
stdev <-
function(x, na.rm = F)
{
    if(na.rm)
       x <- x[!is.na(x)]
    if(length(x) == 0)
       NA
    else sqrt(var(x))
}
strellis.device <-
function(device, color = (device.name != "postscript" && device.name != 
    "win.printer"), printer.type = "postscript", ...)
{
    if(missing(device)) {
       if(exists("win.graph"))
          device <- "win.graph"
       else if(exists("motif"))
          device <- "motif"
       else if(exists("iris4d"))
          device <- "iris4d"
       else if(exists("x11"))
          device <- "x11"
       else stop("a device must be specified to customize")
    }
    if(!is.character(device))
       device.name <- deparse(substitute(device))
    else {
       device.name <- device
       device <- get(device)
    }
    colormap <- if(!is.logical(color)) color else if(color) {
       if(device.name == "iris4d")
          iris.trellis
       else if(device.name == "postscript")
          colorps.trellis[, -1]
    }
    else bwps.trellis
    if(!missing(printer.type)) {
       ok.printer.type <- c("postscript", "ps", "pcl", "laserjet")
       ipt <- charmatch(to.lower(printer.type), ok.printer.type, nomatch = 0)
       if(ipt < 1)
          stop(paste("printer.type must be one of:", paste(ok.printer.type, 
             collapse = ", ")))
       printer.type <- ok.printer.type[ipt]
    }
    fun.call <- sys.call()
    mcall <- match.call(call = fun.call)
    mcall[[1]] <- as.name(device.name)
    mcall[["device"]] <- NULL
    mcall[["color"]] <- NULL
    mcall[["printer.type"]] <- NULL
    switch(device.name,
       iris4d = {
          device(colors = colormap, offset = 100, ...)
          dev.attr.set("trellis.settings", trellis.settings.color)
       }
       ,
       x11 = {
# Bell Labs stat group only
          unix("xrdb -merge /usr/shyu/trellis/x11.trellis")
          device(...)
          dev.attr.set("trellis.settings", trellis.settings.color)
       }
       ,
       postscript = {
          if(!exists("platform") || platform() == "SUNOS5_SPARC") {
# Bell Labs postscript
             device(colors = colormap, ...)
          }
          else {
             if(platform() != "WIN386") {
# S-PLUS Unix postscript
                device.call <- match.call(def = function(colors, 
                   black.and.white, setcolor, horizontal, ...)
                NULL, mcall)
                if(is.null(device.call$colors))
                   device.call$colors <- colormap
                if(is.null(device.call$black.and.white))
                   device.call$black.and.white <- "false"
                if(is.null(device.call$setcolor))
                   device.call$setcolor <- ps.setcolor.hsb
                if(is.null(device.call$horizontal))
                   device.call$horizontal <- F
                eval(device.call)
             }
             else {
# Windows postscript
                device.call <- match.call(postscript, mcall)
                if(is.null(device.call$colors))
                   device.call$colors <- colormap
                eval(device.call)
             }
          }
          if(is.logical(color) && color) {
             dev.attr.set("trellis.settings", trellis.settings.colorps)
          }
          else dev.attr.set("trellis.settings", trellis.settings.bwps)
       }
       ,
       motif = {
          device.call <- match.call(motif, mcall)
          if(!is.null(device.call$options))
             device.call$options <- paste(xcm.trellis.motif, paste(eval(
                device.call$options), collapse = " "))
          else device.call$options <- xcm.trellis.motif
          eval(device.call)
          dev.attr.set("trellis.settings", trellis.settings.motif)
       }
       ,
       openlook = {
          device.call <- match.call(motif, mcall)
          if(!is.null(device.call$options))
             device.call$options <- paste(xcm.trellis.openlook, paste(eval(
                device.call$options), collapse = " "))
          else device.call$options <- xcm.trellis.openlook
          eval(device.call)
          dev.attr.set("trellis.settings", trellis.settings.motif)
       }
       ,
       win.graph = {
          status <- if(color) win.colorscheme("Trellis", quiet = T) else 
                win.colorscheme("Trellis Black on White", quiet = T)
          if(status == 0)
             warning("Could not set Trellis color scheme")
          device(...)
          dev.attr.set("trellis.settings", trellis.settings.wingraph)
       }
       ,
       win.printer = {
          status <- if(color) win.colorscheme("Trellis", quiet = T) else 
                win.colorscheme("Trellis Black on White", quiet = T)
          if(status == 0)
             warning("Could not set Trellis color scheme")
          device.call <- match.call(win.printer, mcall)
          if(is.null(device.call$width))
             device.call$width <- 8
          if(is.null(device.call$height))
             device.call$height <- 10.5
          if(is.null(device.call$pointsize))
             device.call$pointsize <- 14
          eval(device.call)
          switch(printer.type,
             postscript = ,
             ps = if(is.logical(color) && color) dev.attr.set(
                   "trellis.settings", trellis.settings.wincolorps) else 
                   dev.attr.set("trellis.settings", trellis.settings.winbwps),
             pcl = ,
             laserjet = dev.attr.set("trellis.settings", 
                trellis.settings.winpcl))
       }
       ,
       device())
    invisible()
}
strip.trail <-
function(x, trail = " ")
{
# This function strips away trailing characters of specified value
# from character vectors: everything from the first occurrence of the trail
#  character is removed
    begin.spaces <- find.first(x, trail)
    need.strip <- !is.na(begin.spaces)
    x[need.strip] <- substring(x[need.strip], 1, begin.spaces[need.strip] - 1)
    x
}
summarize <-
function(data, y.cols = NULL, split.cols = NULL, rep.col = "Rep", file = "", 
    append = F, help = F, select = c("num", "mean", "sem", "min", "max", 
    "boxplots"), bp.width = 30, between = F, dec = 3, df.out = F, pad = "mid")
{
# Keep Stephen's beginning:
# Requires text.bp(), df.summary(), and df.to.file()
    summary.names <- c("N", "Missing", "Mean", "Median", "Trimmed Mean", 
       "Std. Dev.", "SEM", "Min", "Max", "1st Quartile", "3rd Quartile", "Sum",
       "Boxplots")
    summary.types <- c("num", "missing", "mean", "median", "trm", "stdev", 
       "sem", "min", "max", "q1", "q3", "sum", "boxplots")
    help.df <- (data.frame(Select.this = summary.types, to.get.this = 
       summary.names))
    if(help) {
       cat("\n In the argument \"select\"\n")
       print(help.df)
       return()
    }
    broadcast(bp.width)
    broadcast(dec)    #
# Make character vectors of y.cols and split.cols if necessary:
    if(is.numeric(y.cols))
       y.cols <- names(data)[y.cols]
    if(is.numeric(split.cols)) split.cols <- names(data)[split.cols]    #
# If between reps are needed, first find means for each rep
    if(between) {
       if(file == "")
          cat("\n\t~~~~~~~~~~~ BETWEEN REPLICATES ~~~~~~~~~~~\n\n")
       else write("\n\t~~~~~~~~~~~ BETWEEN REPLICATES ~~~~~~~~~~~\n\n", file = 
             file, append = append)
       append <- T
       data <- df.summary(data = data, y.cols = y.cols, split.cols = c(
          split.cols, rep.col), decimals = 6)
    }
    else {
       if(file == "")
          cat("\n\t********* WITHIN REPLICATES *********\n\n")
       else write("\n\t********* WITHIN REPLICATES *********\n\n", file = file,
             append = append)
       append <- T
    }
    s.tapply <- function(x, y, z, ...)
    tapply(x, y, z, ...)[(unique(y))]
    q1 <- function(x)
    quantile(x, na.rm = T)[2]
    q3 <- function(x)
    quantile(x, na.rm = T)[4]
    no.missing <- function(x)
    length(x[is.na(x)])
    len.rm <- function(x)
    length(x[!is.na(x)])
    round.stdev <- function(x, y = dec)
    round(stdev(x, na.rm = T), y)
    round.mean <- function(x, y = dec)
    round(mean(x, na.rm = T), y)
    round.sem <- function(x, y = dec)
    round(sem(x, na.rm = T), y)
    round.max <- function(x, y = dec)
    round(max(x, na.rm = T), y)
    round.min <- function(x, y = dec)
    round(min(x, na.rm = T), y)
    round.median <- function(x, y = dec)
    round(median(x, na.rm = T), y)
    add.boxplot <- function(x, y.range = range.j, width = bp.width)
    text.bp(x, y.range, width)    #
# Functions are now set up:
#
# Make named vector of functions to be used:
    use.functions <- c("len.rm", "no.missing", "round.mean", "round.median", 
       "trm", "round.stdev", "round.sem", "round.min", "round.max", "q1", "q3",
       "sum", "add.boxplot")
    names(use.functions) <- summary.types
    names(summary.names) <- summary.types    #
# Use dataframes instead of matrices:
    if(is.matrix(data))
       data <- unfactor(as.data.frame(data))
    else data <- unfactor(data)    # avoid pesky factors
    data <- df.sort(data, rev(split.cols))    #
# Create index and adjust for single split columns if necessary:
    indx.df <- data.frame(data[, split.cols])
    names(indx.df) <- split.cols    # Necessary for single split.cols
    attach(indx.df)
    indx <- NULL
    for(i in split.cols)
       indx <- paste(indx, get(i), sep = ":")
    detach("indx.df")
    out.df <- data.frame(indx.df[match(unique(indx), indx), split.cols])
    names(out.df) <- split.cols    # Necessary for single split.cols
    dimnames(out.df) <- list(paste(1:nrow(out.df)), names(out.df))
    for(j in y.cols) {
       range.j <- range(data[, j], na.rm = T)
       broadcast(range.j)
       for(k in select)
          out.df[[summary.names[k]]] <- s.tapply(data[, j], indx, get(
             use.functions[k]))
       if(df.out) {
          names(out.df) <- c(split.cols, paste(j, select, sep = "."))
          return(out.df)
       }
       else {
# Get rid of row number names:
          out.mat <- as.matrix(out.df)
          dimnames(out.mat)[[1]] <- rep("", nrow(out.mat))
          out.df <- as.data.frame(out.mat)
          numeric.cols <- !sapply(out.df, function(x)
          any(is.na(as.numeric(x))))
          out.df[numeric.cols] <- lapply(out.df[numeric.cols], as.numeric)
          underlines <- paste(rep("=", nchar(j)), collapse = "")
          if(file == "") {
             cat(paste("\n ", j, "\n", sep = ""))
             cat(paste(" ", underlines, "\n", sep = ""))
             print(out.df)
          }
          else {
             write(paste("\n", j), file = file, append = append)
             append <- T    # hereafter appending will always be wanted
             write(paste(" ", underlines, sep = ""), file = file, append = T)
             df.to.file(out.df, file = file, append = append, pad = pad)
          }
       }
    }
    invisible()
}
summarize.new <-
function(data, y.cols = NULL, split.cols = NULL, rep.col = "Rep", file = "", 
    append = F, dec = 3, narrow = T, help = F, bp.width = 30, select = c("num",
    "mean", "sem", "min", "max", "boxplots"), df.out = F, pad = "mid")
{
# Keep Stephen's beginning:
# Requires text.bp.new() and df.to.file()
    summary.names <- c("N", "Missing", "Mean", "Median", "Trimmed Mean", 
       "Std. Dev.", "SEM", "Min", "Max", "1st Quartile", "3rd Quartile", "Sum",
       "Boxplots")
    summary.types <- c("num", "missing", "mean", "median", "trm", "stdev", 
       "sem", "min", "max", "q1", "q3", "sum", "boxplots")
    help.df <- (data.frame(Select.this = summary.types, to.get.this = 
       summary.names))
    if(help) {
       cat("\n In the argument \"select\"\n")
       print(help.df)
       return()
    }
    broadcast(bp.width)
    broadcast(dec)    #
# Make special functions to use in apply calls
#to avoid tapply's nasty habits...
    s.tapply <- function(x, y, z, ...)
    tapply(x, y, z, ...)[(unique(y))]
    q1 <- function(x)
    quantile(x, na.rm = T)[2]
    q3 <- function(x)
    quantile(x, na.rm = T)[4]
    no.missing <- function(x)
    length(x[is.na(x)])
    round.mean <- function(x, y = dec)
    round(mean(x, na.rm = T), y)
    round.sem <- function(x, y = dec)
    round(sem(x, na.rm = T), y)
    add.boxplot <- function(x, y.range = range.j, width = bp.width)
    text.bp.new(x, y.range, width)    #
# Functions are now set up:
#
# Make named vector of functions to be used:
    use.functions <- c("len", "no.missing", "round.mean", "median", "trm", 
       "stdev", "round.sem", "min", "max", "q1", "q3", "sum", "add.boxplot")
    names(use.functions) <- summary.types
    names(summary.names) <- summary.types    #
# Use dataframes instead of matrices:
    if(is.matrix(data))
       data <- unfactor(as.data.frame(data))
    data <- df.sort(data, rev(split.cols))    #
# Make character vectors of y.cols and split.cols if necessary:
    if(is.numeric(y.cols))
       y.cols <- names(data)[y.cols]
    if(is.numeric(split.cols)) split.cols <- names(data)[split.cols]    #
# Create index and adjust for single split columns if necessary:
    indx.df <- data.frame(data[, split.cols])
    names(indx.df) <- split.cols    # Necessary for single split.cols
    attach(indx.df)
    indx <- NULL
    for(i in split.cols)
       indx <- paste(indx, get(i), sep = ":")
    detach("indx.df")
    out.df <- data.frame(indx.df[match(unique(indx), indx), split.cols])
    names(out.df) <- split.cols    # Necessary for single split.cols
    dimnames(out.df) <- list(paste(1:nrow(out.df)), names(out.df))
    append <- append
    for(j in y.cols) {
       if(!df.out) {
          underlines <- paste(rep("=", nchar(j)), collapse = "")
          if(file == "") {
             cat(paste("\n ", j, "\n", sep = ""))
             cat(paste(" ", underlines, "\n", sep = ""))
          }
          else {
             write(paste("\n", j), file = file, append = append)
             append <- T    # herafter appending will always be wanted
             write(paste(" ", underlines, sep = ""), file = file, append = T)
          }
       }
       range.j <- range(data[, j])
       broadcast(range.j)
       for(k in select) {
          out.df[[summary.names[k]]] <- s.tapply(data[, j], indx, get(
             use.functions[k]))
       }
       if(df.out) {
          names(out.df) <- c(split.cols, paste(j, select, sep = "."))    
    #y.cols)
          return(out.df)
       }
       else {
# Get rid of row number names:
          out.mat <- as.matrix(out.df)
          dimnames(out.mat)[[1]] <- rep("", nrow(out.mat))
          out.df <- as.data.frame(out.mat)
          numeric.cols <- !sapply(out.df, function(x)
          any(is.na(as.numeric(x))))
          out.df[numeric.cols] <- lapply(out.df[numeric.cols], as.numeric)
          if(file == "")
             print(out.df)
          else df.to.file(out.df, file = file, append = append, pad = pad)
       }
    }
    invisible()
}
tab.file <-
function(x, file, rounding = 3, ...)
{
# To write a dataframe or matrix to a tab delimited file
    if(!is.null(rounding)) {
       if(is.data.frame(x))
          x <- as.matrix(x)
       x <- round(x, rounding)
    }
    write.table(x, file, sep = "\t", ...)
}
tab.mat <-
function(mat)
{
    rownames <- dimnames(mat)[[1]]
    colnames <- dimnames(mat)[[2]]
    cat(c("\t", paste(colnames, collapse = "\t")), "\n")
    for(i in 1:dim(mat)[1]) {
       cat(paste(c(rownames[i], mat[i,  ]), collapse = "\t"), "\n")
    }
}
table.all <-
function(x, own.seq = seq(0, 3, by = 0.5), minx = 0, maxx = NULL)
{
# returns a table that indicates a zero if the value is absent
# 1a) if else when specifying own sequence
    if(!is.null(own.seq)) {
       same.intervals <- mean(diff(own.seq))
       if(all(diff(own.seq) == same.intervals)) {
          table(c(x, own.seq)) - 1
       }
       else {
          stop("Sequence steps not all the same")
       }
    }
    else {
# 1b) when own sequence is NULL
# 2) if else when specifying a maximum for x
       if(!is.null(maxx)) {
          table(c(x, minx:maxx)) - 1
       }
       else {
          table(c(x, minx:max(x, na.rm = T))) - 1
       }
    }
}
text.bp <-
function(x, y.range, width = 45, no.data.string = "NA")
{
# Does a "text boxplot" to use in summarize()
    x <- x[!is.na(x)]
    if(length(x) < 1)
       return(no.data.string)
    x.quan <- rev(boxplot(x, plot = F)$stats[, 1])
    x.outliers <- boxplot(x, plot = F)$out
    if(!is.null(x.outliers))
       out.pos <- round(approx(seq(y.range[1], y.range[2], length = width), 1:
          width, xout = x.outliers)$y)
    qps <- round(approx(seq(y.range[1], y.range[2], length = width), 1:width, 
       xout = x.quan)$y)    #
# Have quantile positions...
# Make allowances for overlapping positions of quantiles
#
    qps.start <- qps
    if(prod(diff(qps[-3])) == 0) {
       if(qps[2] - qps[1] < 1)
          qps[2] <- qps[1] + 1
       if(qps[5] - qps[4] < 1)
          qps[4] <- qps[4] - 1
       if(qps[4] - qps[2] < 1) {
          if(qps[5] < width)
             qps[4:5] <- qps[4:5] + 1
          else qps[1:2] <- qps[1:2] - 1
       }
    }
    bar.vec <- rep(" ", width)
    bar.vec[qps[1]] <- "("
    bar.vec[qps[2]] <- "["
    bar.vec[qps[4]] <- "]"
    bar.vec[qps[5]] <- ")"
    if(qps[2] - qps[1] > 1)
       bar.vec[(qps[1] + 1):(qps[2] - 1)] <- "."
    if(qps[4] - qps[2] > 1)
       bar.vec[(qps[2] + 1):(qps[4] - 1)] <- "-"
    if(qps[5] - qps[4] > 1) bar.vec[(qps[4] + 1):(qps[5] - 1)] <- "."    #
# Add in outliers if present
    if(!is.null(x.outliers))
       bar.vec[out.pos] <- "*"
    bar.tex <- paste(bar.vec, collapse = "")
    full.bar.tex <- paste(":", bar.tex, ":", sep = "")
}
text.bp.new <-
function(x, y.range, width = 45, no.data.string = "NA")
{
# Does a "text boxplot" to use in summarize()
    x <- x[!is.na(x)]
    if(length(x) < 1)
       return(no.data.string)
    x.quan <- rev(boxplot(x, plot = F)$stats[, 1])
    x.outliers <- boxplot(x, plot = F)$out
    if(!is.null(x.outliers))
       out.pos <- round(approx(seq(y.range[1], y.range[2], length = width), 1:
          width, xout = x.outliers)$y)
    qps <- round(approx(seq(y.range[1], y.range[2], length = width), 1:width, 
       xout = x.quan)$y)    #
# Have quantile positions...
# Make allowances for overlapping positions of quantiles
#
    qps.start <- qps
    if(prod(diff(qps[-3])) == 0) {
       if(qps[2] - qps[1] < 1)
          qps[2] <- qps[1] + 1
       if(qps[5] - qps[4] < 1)
          qps[4] <- qps[4] - 1
       if(qps[4] - qps[2] < 1) {
          if(qps[5] < width)
             qps[4:5] <- qps[4:5] + 1
          else qps[1:2] <- qps[1:2] - 1
       }
    }
    bar.vec <- rep(" ", width)
    bar.vec[qps[1]] <- "("
    bar.vec[qps[2]] <- "["
    bar.vec[qps[4]] <- "]"
    bar.vec[qps[5]] <- ")"
    if(qps[2] - qps[1] > 1)
       bar.vec[(qps[1] + 1):(qps[2] - 1)] <- "."
    if(qps[4] - qps[2] > 1)
       bar.vec[(qps[2] + 1):(qps[4] - 1)] <- "-"
    if(qps[5] - qps[4] > 1) bar.vec[(qps[4] + 1):(qps[5] - 1)] <- "."    #
# Add in outliers if present
    if(!is.null(x.outliers))
       bar.vec[out.pos] <- "*"
    bar.tex <- paste(bar.vec, collapse = "")
    full.bar.tex <- paste(":", bar.tex, ":", sep = "")
}
time.to.mort <-
function(ab, link = "cloglog", pc = 0.99996830000000003)
{
# For calculating time to (by default) Probit9 mortality, or any other %
#
# Note: if the x-axis has used a transformation before fitting the line, 
#  the reverse transformation must be made to this output.
#
    f <- link.function(link)
    targ <- f(ab$cm + (1 - ab$cm) * pc)
    lt <- (targ - ab$intercept)/ab$slope
    lt
}
tuk.calc <-
function(comp = 3, error.df = 50, se = 0.2029, interval = 0.94999999999999996, 
    sed.logical = T)
{
    if(sed.logical) {
       qtukey(interval, comp, error.df) * (se/sqrt(2))
    }
    else {
       qtukey(interval, comp, error.df) * se
    }
}
unfactor <-
function(x, cols = "every.factor.column", notify = F)
{
#Converts factors back to numerics or character vectors
#
# A dataframe (or vector) of the same dimensions and names is returned
# Default is to change all factor columns 
# Alternatively, specific columns can be specified
#
# notify:  Notify that no factors need changing? 
# Vectors have to be handled differently:
    onecol <- is.null(dim(x))
    if(is.null(dim(x))) {
       x <- as.data.frame(x)
       cols <- 1
    }
# Handling data frames:
    if(is.numeric(cols))
       change.cols <- cols
    else {
       if(cols == "every.factor.column") {
          fact.cols <- check.fact(x)
          change.cols <- find.pos(T, fact.cols)    #
# (a numerical vector of column numbers that are to be changed)
       }
       else change.cols <- find.pos(cols, names(x))
    }
    if(length(change.cols) == 0 & notify)
       cat(paste("No factors to change in", as.character(substitute(x)), "\n"))
    else {
       options(warn = -1)
       on.exit(options(warn = 0))
       for(i in change.cols) {
          levels.i <- levels(x[[i]])
          level.nos <- as.numeric(levels.i)
          numbers <- ifelse(any(is.na(level.nos)), F, T)
          if(numbers)
             x[, i] <- as.numeric(I(as.character(x[, i])))
          else x[, i] <- I(as.character(x[, i]))
       }
    }
    if(onecol)
       x <- as.vector(unlist(x))
    x
}
vec.insert <-
function(values, into, at)
{
# For inserting values into a vector at designated positions.
# "at" is a vector of  numbers in the original vector ("into") at which insertion 
#   is req'd and should be the same length as the no of "values".
    if(length(values) != length(at)) stop(
          "Number of values must be the same as no of places")
    at.inc <- at
    for(a in 1:length(at)) {
       if(at.inc[a] == 1)
          top <- NULL
       else top <- into[1:(at.inc[a] - 1)]
       bottom <- into[at.inc[a]:length(into)]
       into <- c(top, values[a], bottom)
       at.inc <- at.inc + 1
    }
    into
}
vect.to.character <-
function(vec, sep = ", ")
{
# Pastes all elements of a vector into a single character object
    if(length(vec) == 1) out.obj <- vec else {
       out.obj <- vec[1]
       for(k in 2:length(vec)) {
          out.obj <- paste(out.obj, vec[k], sep = sep)
       }
    }
}
